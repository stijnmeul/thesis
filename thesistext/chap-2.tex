\chapter{Literature Review}
\label{cha:2}

% TODO: write intro
% TODO: gebruik Martijn Maas thesis om iets te zeggen over public crypto, CA's en openPGP

\section{Identity-Based Encryption}
Shamir~\cite{art:Shamir84} already proposed a concept of identity-based cryptography in 1984. In identity-based cryptography any string can be a valid public key for encryption or signature schemes thereby eliminating the need for digital certificates. Identity-based cryptography proves to be particularly elegant if the public key is related to an attribute that uniquely identifies the identity of the user like an e-mail address, an IP address or a telephone number. Consequently, identity-based cryptography reduces system complexity and the cost for establishing and managing the Public Key Infrastructure~(PKI)~\cite{art:BaekNSS04}. 


\subsection{Definition}
A generic Identity-Based Encryption (IBE) scheme is composed of four probabilistic polynomial time algorithms~\cite{art:BonehF01}:
\begin{description}
    \item[\texttt{IBE.Setup($1^{\lambda}$)}] On input of a security parameter $\lambda$, outputs a master secret $s_k$ and public parameters $params$.
    \item[\texttt{IBE.Extract($params, s_k, \id{}$):}] Takes public parameters $params$, the master secret $s_k$, and an \id{} as input and returns the private key $s_{\id{}}$ corresponding to the identity \id{}.
    \item[\texttt{IBE.Encrypt($params, \id{}, m$):}] Returns the encryption $c$ of the message $m$ on the input of the public parameters $params$, the \id{}, and the arbitrary length message $m$.
    \item[\texttt{IBE.Decrypt($s_{\id{}}, c$):}] Decrypts the ciphertext $c =$ \texttt{IBE.Encrypt}($params, \id{}, m$) back to the message $m$ on input of the secret key $s_{\id{}}$ corresponding to the receiving identity \id{}.
\end{description}

\begin{figure}[ht]
    \begin{center}
    \scalebox{0.78}{
        \begin{tikzpicture}[auto, node distance=1mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=11mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            ]
            %\draw[help lines] (-6,-5) grid (8,3);
            \path
                % Images
                (-0.5,3) node [block] (pkg) {\includegraphics[scale=0.2]{img/pkg.png}}
                (-4,0) node [block] (alice) {\includegraphics[scale=0.2]{img/alice.png}}
                (4,0) node [block] (bob) {\includegraphics[scale=0.2]{img/bob.png}}
                % Text
                (-0.5, 0.5) node [leg, color=orange] (c) {$c$}
                (1.5, 1.2) node [leg] (id_bob) {$s_{\id{Bob}}$}
                (4.3,2) node [leg] (bob_authenticates) {4. Bob authenticates as \id{Bob}}
                ;
                
       \node[below=of pkg] {\textbf{PKG}};
       \node[below=of alice] {\textbf{Alice} \\ 3. $c \leftarrow $\texttt{IBE.Encrypt($params, \id{Bob}, m$)}};
       \node[below=of bob] {\textbf{Bob} \\ 6. $m \leftarrow $\texttt{IBE.Decrypt($s_{\id{Bob}}, \id{Bob}, c$)}};
       \node[above=of pkg,align=left] {
               1. $\left< s_k, params \right> \leftarrow $\texttt{IBE.Setup($1^{\lambda}$)} \\
               2. publish $params$ \\
               \\
               5. $s_{\id{Bob}} \leftarrow $\texttt{IBE.Extract($params, s_k, \id{Bob}$)}
               };
       \begin{scope}[every path/.style=line]
        \path[color=orange] (alice.east) -- (bob.west);
        \path (2.8,1) -- (1,2.2);
        \path (0.9,2.1) -- (2.7,0.9);
       \end{scope}


        \end{tikzpicture}
    }
    \end{center}
    \caption{Generic identity-based encryption scheme. The orange arrow denotes an insecure channel that can be eavesdropped.}
    \label{fig:generic_ibe_scheme}
\end{figure}

These generic algorithms are best explained using Figure~\ref{fig:generic_ibe_scheme}. A trusted Public Key Generator (PKG) generates a master secret key $s_k$ and public parameters $params$ on input of the security parameter $k$. Next, the PKG publishes the public parameters $params$ while storing $s_k$ preferably in encrypted fashion on a local disk. When Alice wants to send a message $m$ to Bob, it suffices for her to know the public parameters $params$ and his id $\id{Bob}$ uniquely identifying Bob. Alice encrypts the message to a ciphertext $c$ that is sent over to Bob. On receipt of the ciphertext, Bob authenticates to the PKG over a secure channel to request his secret key $s_{\id{Bob}}$. Next, the PKG generates the secret key $s_{\id{Bob}}$ corresponding to Bob's identity $\id{Bob}$ on input of the master secret key $s_k$, Bob's id $\id{Bob}$ and public parameters $params$. Subsequently, the PKG sends $s_{\id{Bob}}$ back again over a secure channel. Finally, Bob has all the required information to decrypt the ciphertext $c$ to its original plaintext message $m$.

\subsection{Advantages and Drawbacks of IBE}
Note that it is important that the PKG can be fully trusted as it will generate all the secret keys $s_{\id{}}$ in the system. Referring to Figure~\ref{fig:generic_ibe_scheme}, a malicious PKG server could use this information to start eavesdropping on the insecure channel between Alice and Bob while decrypting all ciphertexts that are being sent over. The undesired property that private keys have to be shared with a trusted third party is often called \textit{key escrow} in literature.

Another drawback from the scheme in Figure~\ref{fig:generic_ibe_scheme} is that keys can not be revoked in the system. However, Bob's secret key $s_{\id{Bob}}$ can still get compromised if he is careless with the storage of his secret key. In fact, a lot of research has been done in literature on the revocation of IBE keys~\cite{art:BoldyrevaGK12,art:BonehDTW01,art:HanaokaHSI05,art:LibertQ03}. Key revocation often requires additional infrastructure that complicates the elegancy of the currently proposed IBE scheme. As a matter of fact, the major drawback of revoking Bobs key is that Bob can no longer receive encrypted messages because his public key is part of his identity. Therefore, a pragmatic solution to this issue could be to append expiration dates to the public keys. Consequently, public keys will only be valid for a limited amount of time thereby restricting the damage that could be done with a compromised secret key~\cite{art:BonehF01}.

The scheme from Figure~\ref{fig:generic_ibe_scheme} has some desired properties as well. For starters, only one PKG suffices to realise the system, which relaxes expensive requirements on the public key infrastructure. Furthermore, once the PKG has successfully delivered all the secret keys in the system, it can go offline as the scheme does not require any future interactions between the PKG and the users in the system.

Another useful property of an IBE scheme is that Bob does not need to subscribe to a hierarchy of Certification Authorities neither a chain of trust before Alice can start sending him messages. In this way, the possibility to send encrypted messages becomes inherently part of any system in which the users are assigned unique identifiers. This is particularly useful in systems where the majority of the users has no knowledge about cryptographic primitives.  Users do no longer need to generate a key pair neither subscribe to a third party infrastructure. It suffices to recall how their connections can be uniquely identified in the system to know their public keys.

\subsection{Security of IBE}
A cryptographic scheme should meet two properties in order to be of practical use. First, the scheme should be consistent, i.e. decryption reverses encryption. Second, the scheme should be secure. The definition of security is more subtle as different levels of security can be defined. In IBE \textit{indistinguishability under chosen plaintext attack} (IND-CPA) and \textit{indistinguishability under chosen ciphertext attack} (IND-CCA) are often considered. Anonymity of the encryption scheme is an additional property of the scheme that is often desired~\cite{thesis:Alfredo08}.

Note that both the notion of IND-CPA, IND-CCA and anonymity are only introduced in an informal way in this section to give a basic understanding of these concepts to the reader. If a more formal description of IND-CPA and IND-CCA is required, the reader is referred to~\cite{art:BonehF01}. For a more formal description of ciphertext anonymity the reader is referred to~\cite{art:AbdallaBCKKLMNPS05}.

\subsubsection{Indistinguishability Under Chosen Plaintext Attack}
Indistinguishability under chosen plaintext attack (IND-CPA) means that an adversary has no advantage in trying to determine which of both given plaintext messages $m_0$ and $m_1$ generated a ciphertext $c$. It captures the notion of \textit{semantic security}, i.e. that every ciphertext $c$ should not give any more information about the original plaintext $m$ than any other random binary string of the same length.

IND-CPA is best defined with the help of a game that challenges the adversary. If the adversary has negligible advantage trying to win the IND-CPA game in Algorithm~\ref{alg:ind_cpa_game}, the IBE system is said to be IND-CPA secure.

\begin{algorithm}
\caption{Generic IBE-IND-CPA Game~\cite{thesis:Alfredo08}}
\label{alg:ind_cpa_game}
 \textbf{Goal}: An adversary is challenged by a game to check the IND-CPA security of an IBE scheme.
 
 \textbf{Result}: This IBE-IND-CPA Game helps to define the concept of IND-CPA security for IBE schemes.

 \begin{enumerate}
  \item The challenger runs $\left< s_k, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:firs_oracle_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a secret key $s_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, s_k, \id{}$)} corresponding to an adversary defined identity $\id{i}$.
  \item The adversary picks two equal length plaintext messages $m_0$ and $m_1$ and an identity $\id{encrypt}$. The adversary honestly passes $\left< m_0, m_1, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and executes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{}, m_b$)}. The challenger gives $c$ to the adversary.
  \item \label{item:second_oracle_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. If $b \neq b'$ or if the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:firs_oracle_query} or step~\ref{item:second_oracle_query}, the adversary loses the game.
 \end{enumerate}
\end{algorithm}

\subsubsection{Indistinguishability Under Chosen Ciphertext Attack}
Indistinguishability under chosen ciphertext (IND-CCA) is a more demanding level of security. Therefore, an algorithm that is IND-CCA secure is considered more secure than an IND-CPA secure algorithm. IND-CCA security means that an adversary has no advantage in trying to determine which of both given plaintext messages $m_0$ and $m_1$ generated a ciphertext $c$ even if the adversary has access to a list of plaintext, ciphertext tuples.

IND-CCA is easiest to define with the help of a game that challenges an adversary similar to the IND-CPA game. The IND-CCA game contains two additional steps compared to the IND-CPA game in which the adversary gets access to another oracle. If the adversary has negligible advantage trying to win the IND-CCA game from Algorithm~\ref{alg:ind_cca_game}, the IBE system is said to be IND-CCA secure.

In literature a distinction is often made between a \textit{non-adaptive} case (IND-CCA1) and an \textit{adaptive} case (IND-CCA2) of IND-CCA. In the non-adaptive case, step 6 of Algorithm~\ref{alg:ind_cca_game} is not allowed. More precisely, an IBE scheme that satisfies Algorithm~\ref{alg:ind_cca_game} is said to be IND-CCA2 secure.

\begin{algorithm}
\caption{Generic IBE-IND-CCA Game~\cite{thesis:Alfredo08}}
\label{alg:ind_cca_game}
 \textbf{Goal}: An adversary is challenged by a game to check the IND-CCA security of an IBE scheme.
 
 \textbf{Result}: This IBE-IND-CCA Game helps to define the concept of IND-CPA security for IBE schemes.

 \begin{enumerate}
  \item The challenger runs $\left< s_k, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:cca_first_oracle_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a secret key $s_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, s_k, \id{}$)} corresponding to an adversary defined identity $\id{i}$.
  \item \label{item:cca_first_decryption_query} The adversary can start querying another oracle $O_{Decrypt} \left( s_{\id{i}}, c_j \right)$ that returns a plaintext $m_j \leftarrow$ \texttt{IBE.Decrypt($s_{\id{i}}, c_j$)} corresponding to an adversary defined ciphertext $c_j$ and identity $\id{i}$.
  \item The adversary picks two equal length plaintext messages $m_0$ and $m_1$ and an identity $\id{encrypt}$. The adversary honestly passes $\left< m_0, m_1, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and executes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{}, m_b$)}. The challenger gives $c$ to the adversary.
  \item \label{item:cca_second_oracle_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item \label{item:cca_second_decryption_query} The adversary continues querying the oracle $O_{Decrypt} \left( s_{\id{i}}, c_j \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. If $b \neq b'$, if the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:cca_first_oracle_query} or step~\ref{item:cca_second_oracle_query} or if the adversary queried the oracle $O_{Decrypt} \left( s_{\id{i}}, c_j \right)$ with $c_j = c$ during step~\ref{item:cca_first_decryption_query} or step~\ref{item:cca_second_decryption_query}, the adversary loses the game.
 \end{enumerate}
\end{algorithm}

\subsubsection{Anonymous Identity-Based Encryption}
An IBE scheme is called anonymous (ANO-IBE) when the ciphertext does not leak the identity of the recipient. In the case of Figure~\ref{fig:generic_ibe_scheme}, this would mean that no eavesdropper on the insecure channel between Alice and Bob could derive that Bob is the recipient based on the information in the ciphertext $c$ alone~\cite{art:BoyenW06}.

ANO-IBE is easiest to define with the help of a game that challenges an adversary similar to the IND-CPA game. If the adversary has negligible advantage trying to win the ANO-IBE game in Algorithm~\ref{alg:ano_ibe}, the IBE system is said to be anonymous.

Gentry~\cite{art:Gentry06} is the first to combine the notions of IND-CPA and IND-CCA with ANO-IBE. A system is then said to be IND-ANO-CPA secure or IND-ANO-CCA secure if it satisfies a modified version of the game in Algorithm~\ref{alg:ano_ibe}. For a more detailed discussion on the topic the reader is referred to the original paper~\cite{art:Gentry06}.

\begin{algorithm}
\caption{Generic ANO-IBE Game~\cite{thesis:Alfredo08}}
\label{alg:ano_ibe}
 \textbf{Goal}: An adversary is challenged by a game to check the ANO-IBE security of an IBE scheme.
 
 \textbf{Result}: This ANO-IBE Game helps to define the concept of ANO-IBE security for IBE schemes.
 \begin{enumerate}
  \item The challenger runs $\left< s_k, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:first_ano_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a secret key $s_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, s_k, \id{i}$)} corresponding to an adversary defined identity $\id{i}$.
  \item The adversary picks a plaintext message $m$ and an identity \id{encrypt}. The adversary honestly passes $\left< m, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and computes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{encrypt}, m$)} if $b=0$. If $b=1$, the challenger computes $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{encrypt}, r$)} where $r$ is a random bit sequence with the same length as the message $m$. The challenger gives $c$ to the adversary.
  \item \label{item:second_ano_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. If $b \neq b'$ or if the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:first_ano_query} or step~\ref{item:second_ano_query}, the adversary loses the game.
 \end{enumerate}
\end{algorithm}

% Todo: kijk security levels na: ind-cpa, ind-cca enzoverder adhv winter lecture. Ik vermoed dat daar nog ergens een fout zit.

% Uiteenzetting hoe we tot BF-IBE DKG komen:
%    -> BF-IBE is anoniem, BB is NIET anoniem
%            => zie winter lecture op 
%                  https://www.youtube.com/watch?v=Tt7cJnZDth0&index=8&list=PLXF_IJaFk-9C4p3b2tK7H9a9axOm3EtjA
%    -> SK-IBE en BB vereisen communicatie tussen DKGs
%       tijdens extractie stap.
%    -> SK-IBE berust op BDHI veronderstelling = niet leuk
%    -> BB is vorm van HIBE => totaal aantal gebruikers moet op voorhand worden vastgelegd = niet leuk
\subsection{Evolution of IBE}
\label{sec:evolution_of_ibe}
Although Shamir easily constructed an identity-based signature scheme based on RSA in 1984, the use case of IBE remained an open problem until the introduction of bilinear maps. In~\cite{art:BonehF01} Boneh and Franklin propose the first practically usable IBE scheme based on the Weil pairing. However, the security proof in~\cite{art:BonehF01} still relies on the random oracle assumption. Canetti et al.~\cite{art:CanettiHK03} succeed in proposing a secure IBE scheme without having to rely on the random oracle model. However, the attacker model in~\cite{art:CanettiHK03} requires the adversary to declare which identity \id{} that will be targeted during step 5 of the CCA Game (Algorithm~\ref{alg:ind_cca_game}) and step 4 of the CPA Game, therefore the scheme in~\cite{art:BonehF01} is considered more secure as attackers can adaptively choose the targeted identity. Boneh and Boyen~\cite{art:BonehB04} present a variant to~\cite{art:CanettiHK03} which also realises only selective ID security.  

Waters~\cite{art:Waters05} is the first to present a scheme that is IND-CCA secure in the standard model. Drawback of the scheme from Waters~\cite{art:Waters05} is that it requires large public parameters. Gentry~\cite{art:Gentry06} proposes a more efficient alternative to this scheme in the standard model while achieving shorter public parameters. The scheme from Gentry relies on a complicated hardness assumption called q-BDHE. It is only after the introduction of the Dual System paradigm by Waters~\cite{art:Waters09} in 2009 that IND-CCA security can be achieved in the standard model based on reasonable assumptions.

Although all these contributions were a step forward in the evolution of IBE, not all schemes are ANO-IBE. However, most IBE systems in the random oracle model can be proven anonymous. Therefore, the IBE scheme from Boneh and Franklin~\cite{art:BonehF01} is IND-ANO-CCA secure. In the standard model, it appeared to be harder to construct ANO-IBE schemes at first sight, e.g. it can be proven that the scheme from Boneh and Boyen~\cite{art:BonehB04} is not anonymous in its original form. The scheme from Gentry~\cite{art:Gentry06} was the first anonymous IBE scheme in the standard model. Boyen and Waters~\cite{art:BoyenW06} published almost synchronously another IBE scheme in the standard model that is also IND-ANO-CCA secure. In 2010, Ducas~\cite{art:Ducas10} also showed that even schemes that were first considered not anonymous like the one from Boneh and Boyen~\cite{art:BonehB04} but also~\cite{art:BonehBG05,art:Waters05} can be proven anonymous when relying on asymmetric pairings thereby making anonymity more a rule than an exception in IBE schemes.

\subsection{Boneh and Franklin IBE}
Boneh and Franklin~\cite{art:BonehF01} propose two IBE algorithms called \texttt{BasicIndent} and \texttt{FullIndent} that will prove particularly useful in the remainder of this text. \texttt{BasicIndent} can be proven IND-CPA secure while \texttt{FullIndent} is proven IND-CCA secure. \texttt{BasicIndent} can be found in Algorithm~\ref{alg:basic_indent} while \texttt{FullIndent} is found in Algorithm~\ref{alg:full_indent}.

As already mentioned in Section~\ref{sec:evolution_of_ibe}, the scheme from Boneh and Franklin relies on the random oracle assumption. Furthermore, both schemes are ANO-IBE.

\begin{algorithm}
\caption{BasicIndent~\cite{art:BonehF01}}
\label{alg:basic_indent}
 \textbf{Goal}: Alice wants to send an IBE encrypted message to Bob.
 
 \textbf{Result}: Alice sends an IBE encrypted ciphertext $c$ that is successfully decrypted by Bob.
 \begin{enumerate}
  \item \texttt{Setup($1^{\lambda}$)}: Let $\lambda$ be the security parameter for a security level of $l$ bits.
  \begin{enumerate}
   \item Execute setup algorithm $\left< q, G_1, G_2, e: G_1 \times G_2 \rightarrow G_T, P \in G_1 \right> \leftarrow \mathcal{G} \left( 1^{\lambda} \right)$ to generate the parameters
    \begin{enumerate}
     \item A large prime $q$
     \item Gap groups $G_1$ and $G_2$ of order q
     \item An admissible bilinear map $e: G_1 \times G_2 \rightarrow G_T$
     \item A random generator $P \in G_1$
   \end{enumerate}
   \item Choose a uniformly random $s_k \in \mathbb{Z}^{*}_q$ and calculate
   \begin{equation*}
    P_{pub} = s_k P
   \end{equation*}
   \item Choose cryptographic hash functions
    \begin{enumerate}
     \item $H_1: \left( 0,1  \right)^* \rightarrow G_1$
     \item $H_2: G_2 \rightarrow \left( 0,1 \right)^l$
    \end{enumerate}
  \end{enumerate}
  \item \texttt{Extract($params, s_k, \id{}$)}:
   \begin{enumerate}
    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right) \in G_1$
    \item Set the private key of $\id{}$ to $s_{\id{}} = s_k Q_{\id{}}$
   \end{enumerate}
   \item \texttt{Encrypt($params, \id{}, m$)}:
   \begin{enumerate}
    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right)$
    \item Choose a random $r \in Z_q$
    \item Encrypt the plaintext message $m$ to the ciphertext $c$ as
    \begin{equation*}
     c = \left< rP, m \oplus H_2 \left( g_{\id{}^r} \right) \right> = \left< U, v \right> \; \; \textrm{with} \; \; g_{\id{}} = e \left( Q_{\id{}}, P_{pub} \right) \in G_T
    \end{equation*}
   \end{enumerate}
   \item \texttt{Decrypt($s_{\id{}}, c$)}: Decrypt the ciphertext $c$ back to the plaintext message $m$ as
   \begin{equation*}
    m = v \oplus H_2 \left( e \left( s_{\id{}}, U \right) \right)
   \end{equation*}
 \end{enumerate}
\end{algorithm}

\begin{algorithm}
\caption{FullIndent~\cite{art:BonehF01}}
\label{alg:full_indent}
 \textbf{Goal}: Alice wants to send an IBE encrypted message to Bob.
 
 \textbf{Result}: Alice sends an IBE encrypted ciphertext $c$ that is successfully decrypted by Bob.
 \begin{enumerate}
  \item \texttt{Setup($1^k$)}: 
  \begin{enumerate}
   \item As in the BasicIndent scheme
   \item As in the BasicIndent scheme
   \item Choose cryptographic hash functions
    \begin{enumerate}
     \item $H_1: \left( 0,1  \right)^* \rightarrow G_1$
     \item $H_2: G_2 \rightarrow \left( 0,1 \right)^l$
     \item $H_3: \left( 0,1 \right)^l \rightarrow \left( 0,1 \right)^l$
    \end{enumerate}
  \end{enumerate}
  \item \texttt{Extract($params, s_k, \id{}$)}: As in the BasicIndent scheme
   \item \texttt{Encrypt($params, \id{}, m$)}:
   \begin{enumerate}
    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right)$
    \item Choose a random $sigma \in \left( 0,1 \right)^l$
    \item Compute $r = H_3 \left( sigma, m \right)$
    \item Encrypt the plaintext message $m$ to the ciphertext $c$ as
    \begin{equation*}
     \begin{split}
      c = \left< rP, sigma \oplus H_2 \left( g_{\id{}}^r\right), m \oplus H_3 \left( sigma \right) \right> = \left< U, v, w \right> \\ 
     \; \; \textrm{with} \; \; g_{\id{}} = e \left( Q_{\id{}}, P_pub \right) \in G_T
     \end{split}
    \end{equation*}
   \end{enumerate}
   \item \texttt{Decrypt($s_{\id{}}, c$)}: Decrypt the ciphertext $c$ back to the plaintext message $m$ as follows
   \begin{enumerate}
    \item Compute $sigma = v \oplus H_2 \left( e \left( s_{\id{}}, U \right) \right)$
    \item Compute $m = w \oplus H_3 \left( sigma \right)$
    \item Set $r = H_3 \left( sigma, m \right)$. Test that $U = rP$. If not, reject the ciphertext.
    \item Output $m$ as the decryption of $c$
    \end{enumerate}
 \end{enumerate}
\end{algorithm}



\section{Broadcast Encryption}
Broadcast encryption (BE) was introduced by Fiat and Naor~\cite{art:FiatN93}, as a public-key generalisation to a multi user setting. A BE scheme allows a user to encrypt a message $m$ to a subset $\mathcal{S}$ of users from all users in a public key system, such that, only users in the set $\mathcal{S}$ are able to decrypt the message. The computational overhead of the BE is generally bound to the ciphertext and the number of recipients.

\subsection{Definition}
A generic Broadcast Encryption (BE) scheme is composed of four probabilistic polynomial time algorithms:

\begin{description}
    \item[\texttt{BE.Setup($1^{\lambda}$)}]: On input of a security parameter $\lambda$, generates the public parameters $params$ of the system.
    \item[\texttt{BE.KeyGen($params$)}]: Returns the public and private key ($pk_i,sk_i$) for each user $i$ while taking the public parameters $params$ into account.
    \item[\texttt{BE.Encrypt}]: Takes a set of public key values $\mathcal{S}=\{pk_i \ldots pk_{|\mathcal{S}|}\}$ corresponding to users $i$ in the system along with a plaintext message $m$ to generate a corresponding ciphertext $c$.
    \item[\texttt{BE.Decrypt:}] Reconstructs $m$ from $c$ using the private key $sk_i$ if the corresponding public key $pk_i \in \mathcal{S}$. Otherwise, return $\bot$.
\end{description}

Note that this definition is stated generically enough to allow all kinds of public keys to be used. Therefore, not only traditional PKIs can benefit from BE schemes, but also IBE schemes in which a public identifier \id{i} serves as a public key $pk_i$.

\subsection{Evolution of Broadcast Encryption}
The problem of BE has been widely studied in literature since its first introduction by Fiat and Naor~\cite{art:FiatN93}. This section highlights the most important evolutions of BE in literature. The summary that follows is far from complete as it only considers publications that are relevant to our final goal: achieving user-friendly broadcast encryption for OSNs.

\subsubsection{Broadcast Encryption}
The implementation from Fiat and Naor~\cite{art:FiatN93} requires a ciphertext of size $O \left( t \log^2 t \log n \right)$ to be secure against $t$ colluding users. The first fully collusion resistant scheme was proposed in~\cite{art:NaorNL01} by Naor et al. thereby making the ciphertext size independent of the number of colluding users. Halevy and Shamir further reduce the required ciphertext length for collusion resistant schemes in~\cite{art:HalevyS02}. It is the first paper in a series of many~\cite{art:DodisF02,art:GoodrichST04,art:LewkoSW08} that achieves ciphertext sizes only dependent on the number of revoked users $O \left( r \right)$. Boneh, Gentry and Waters~\cite{art:BonehBG05} are the first to consider utilisation of bilinear maps to realise constant size ciphertexts and $O \left( n \right)$ public keys.

\subsubsection{Identity-Based Broadcast Encryption}
Sakai and Furukawa are the first to define a collusion resistant identity based broadcast encryption (IBBE) scheme in~\cite{SakaiF07}. A collusion resistant IBBE scheme refers to an identity-based broadcast encryption scheme that is secure even if all users that are not in the recipient set $\mathcal{S}$ would collaborate. Independently from~\cite{SakaiF07} Delerabl\'{e}e realises a similar IBBE scheme and claims to be the first as well in~\cite{DelerableeIBBE}.  The size of the public key in both~\cite{SakaiF07} and~\cite{DelerableeIBBE} is proportional to the maximum size of the intended set of recipients while realising short ciphertexts and private keys. 

Baek et al.~\cite{BaekIBEandBE} define an IBBE scheme that requires only one pairing computation. The scheme in~\cite{BaekIBEandBE} is proven secure under the random oracle assumption where the attacker ties himself to a selective-ID attack. Gentry and Waters achieve identity based broadcast encryption with sublinear ciphertexts in~\cite{GentryW08}. Their scheme is proven secure against a stronger notion of adaptive security where the attacker can adaptively alter its queries depending on earlier received information. Barbosa and Farshim~\cite{BarbosaIBEKEM} proposed an identity-based key encapsulation scheme for multiple parties which is an extension of \textit{mKEM} as considered by Smart~\cite{SmartMKEM} to the identity-based setting. An mKEM is a Key Encapsulation Mechanism which takes multiple public keys as input. An encrypted message under mKEM consists of an encapsulated session key $k$ and a symmetric encryption $E_k \left( m \right)$ of the plaintext message $m$ under $k$.
% Nog iets over random oracle assumptions?

\subsection{Anonymous Broadcast Encryption}
All earlier mentioned references describing BE require the intended set of recipients to be published to realise a higher efficiency. Barth, Boneh and Waters~\cite{BarthBonehWaters} are the first to design a BE scheme that takes the anonymity of the recipient into account. The proposed anonymous broadcast encryption (ANOBE) scheme imposes a linear dependency of the ciphertext on the number of recipients and can only be proven secure in the random oracle model. In~\cite{LibertANOBE} Libert et al., propose an alternative ANOBE scheme that is proven secure in the standard model. Both~\cite{BarthBonehWaters} and~\cite{LibertANOBE} propose a tag based system that allows efficient decryption at the cost of making the public master key linear dependent on the total number of users. Krzywiekci et al.~\cite{KrzywieckiKK06} propose a scheme that is proportional to the number of revoked users. In~\cite{YuRL10}, Yu et al. design an architecture that even hides the number of users in the recipient set.

\subsection{Outsider-Anonymous Broadcast Encryption}
Fazio and Perera introduce the notion of outsider anonymous broadcast encryption in~\cite{FazioOutsiderANOBE}. The scheme relies on IBE to encode where a recipient is positioned in a publicly published tree to achieve sublinear ciphertexts. It is remarkable that sublinear ciphertexts are achieved while attaining recipient anonymity to all users that are outside the intended set of receivers. However, the scheme has the drawback of immediately fixing the total number of users that are allowed in the system. Furthermore, an additional architecture is required to maintain the tree of subscribed users. Finally, although IBE is used, the scheme does not allow to represent public keys of users by their public identifiers because the public key needs to be the position of a user in the tree structure of the external architecture. In this way, most of the desirable properties of IBE cancel out.

Although the scheme from Fazio and Perera does not fit the requirements for user-friendly broadcast-encryption in OSNs, it is useful to remember their definition of outsider-anonymity.

\section{Secret Sharing}

\subsection{Definition}
\begin{defn}[Secret Sharing Scheme]
\label{def:secret_sharing_scheme}
 A \textit{Secret Sharing Scheme} is a cryptographic scheme that divides a secret $S$ into $n$ pieces of data $S_1, \ldots, S_n$ called \textit{shares}. Shares are distributed over $n$ different parties called \textit{shareholders} such that specific subsets of the distributed shares allow reconstruction of the original secret $S$.
\end{defn}

\begin{defn}[Threshold scheme]
\label{def:threshold_scheme}
 A $\left( t, n \right)$ \textit{threshold scheme} $\left( t \leq n \right)$ is a secret sharing scheme by which a trusted party securely distributes $n$ different shares $S_i$ to $n$ different parties $P_i$ for $1 \leq i \leq n$ such that any subset of $t$ or more different shares $S_i$ easily allows to reconstruct the original secret $S$. Knowledge of $t-1$ or less shares is insufficient to reconstruct the original secret $S$.
\end{defn}

\begin{defn}[Perfect threshold scheme]
\label{def:threshold_scheme}
 A $\left( t, n \right)$ threshold scheme is said to be \textit{perfect} if no subset of fewer than $t$ shareholders can derive any partial information in the information theoretic sense about the original secret $S$ even with infinite computational resources.
\end{defn}

\subsection{Shamir Secret Sharing}
In 1979, both Shamir~\cite{art:Shamir79} and Blakley~\cite{art:Blakley79} independently found an algorithm achieving perfect threshold secret sharing. Shamir's solution was based on polynomial interpolation while Blakley's algorithm relied on finite geometries. Blakley secret sharing uses more bits than necessary as it describes multidimensional planes. In contrast, Shamir secret sharing requires as many bits for each share as the length of the original secret. Therefore Shamir secret sharing has gained more popularity in both research communities and in practical implementations.

\begin{algorithm}
\caption{Shamir's $\left( t, n \right)$ threshold scheme~\cite{book:handbook_of_applied_cryptography} }
\label{alg:shamirs_threshold_sheme}
 \textbf{Goal}: A trusted party $T$ distributes shares of a secret $S$ to $n$ parties.
 
 \textbf{Result}: If a subset of at least $t$ out of $n$ shareholders collaborates, they can reconstruct the original secret $S$.
 \begin{enumerate}
  \item \textit{Setup} The trusted party T begins with a secret integer $S \geq 0$ it wishes to distribute among $n$ parties
   \begin{enumerate}
    \item T chooses a prime $p > \max \left( S, n \right)$ and defines $a_0 = S$
    \item $T$ selects $t-1$ random, independent coefficients $a_1, \ldots, a_{t-1}, 0 \leq a_j \leq p-1$ defining the random polynomial over $\mathcal{Z}_p$, $f \left( x \right) = \sum^{t-1}_{j=0} a_j x^j$
    \item $T$ computes $S_i = f \left( i \right) \bmod p, 1 \leq i \leq n$ and securely transfers the share $S_i$ to shareholder $P_i$, along with a public index $i$.
   \end{enumerate}
   \item \textit{Reconstruction} Any group of $t$ or more shareholders pool their shares. Their shares provide $t$ distinct points $\left( x, y \right) = \left( i, S_i \right)$ allowing computation of the coefficients $a_j, 1 \leq j \leq t-1$ of $f \left( x \right)$ by Lagrange interpolation. The secret is recovered by calculating
 \begin{equation*}
  f \left( 0 \right) = \sum^t_{i=1}y_i \prod_{1 \leq j \leq t, j \neq i} \frac{x_j}{x_j-x_i} = S
 \end{equation*}
 \end{enumerate}
\end{algorithm}

The idea behind Shamir secret sharing is elegant in its simplicity. Any polynomial $f \left( x \right)$ of degree $t-1$ is uniquely defined by $t$ points lying on the polynomial. For example, it is possible to draw only one straight line between 2 different coordinates, a quadratic is fully defined by 3 different coordinates and so on. If the trusted party randomly generates a polynomial of degree $t-1$ it suffices to securely distribute one of $n$ different coordinates on the curve to each party $P_i, 0 \leq i \leq n$. A subset of at least $t$ different shareholders has to collaborate in order to reconstruct the original polynomial by interpolation. For security reasons the polynomial $f \left( x \right)$ is calculated in a finite field modulo a large prime number $p$. The complete mechanism of Shamir's threshold scheme can be found in Algorithm~\ref{alg:shamirs_threshold_sheme}. The mechanism behind reconstruction in Algorithm~\ref{alg:shamirs_threshold_sheme} is explained because the coefficients of an unknown polynomial $f \left( x \right)$ of degree less than $t$, defined by points $\left( x_i, y_i \right), 1 \leq i \leq t$ are given by the Lagrange interpolation formula

\begin{equation*}
 f \left( x \right) = \sum^t_{i=1}y_i \prod_{1 \leq j \leq t, j \neq i} \frac{x-x_j}{x_i-x_j}
\end{equation*}
A proof of this formula is omitted but can be found in~\cite{site:proofwiki_lagrange}.

\subsection{Verifiable Secret Sharing}
Verifiable secret sharing~\cite{art:ChorGMA85} tries to ensure the participating parties that their received shares are consistent by providing a verification mechanism. This verification mechanism can either detect an unfair dealer during setup or participants submitting incorrect shares during the reconstruction phase. The first verifiable secret sharing schemes were \textit{interactive}, i.e. interaction between shareholders and the trusted party was required to verify their shares. In \textit{non-interactive verifiable secret sharing} only the trusted party is allowed to send messages to the future shareholders. Shareholders can not communicate with each other neither can they send messages back to the trusted party. Non-interactive verifiable secret sharing is preferred over interactive alternatives as their is no chance of shareholders accidentally leaking too much information.

Popular verifiable secret sharing schemes are Feldman's scheme~\cite{art:Feldman87} and Benaloh's scheme~\cite{art:Benaloh86a}. No further details are given as a basic notion of verifiable secret sharing suffices for the remainder of this text.

\section{Distributed Key Generation}

\section{Conclusion}
The final section of the chapter gives an overview of the important results of this chapter. This implies that the introductory chapter and the concluding chapter don't need a conclusion.

\lipsum[66]

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
