\chapter{Cryptographic Building Blocks}
\label{cha:2}
This chapter overviews the cryptographic building blocks used to design the encryption mechanism for online social networks proposed in this thesis.

The structure of this chapter is the following. An introduction is given to public key infrastructures and their drawbacks. Then, identity-based encryption (IBE) is overviewed as an alternative to the existing public key infrastructures along with its drawbacks and advantages, the different security definitions and the evolution of IBE in literature. This is followed by an elaborate discussion on broadcast encryption (BE) and secret sharing. Finally, distributed key generation is described as a possible solution to the inherent key escrow problem of IBE.

\section{Public Key Infrastructures}
Asymmetric cryptography assigns users a key pair $\left< sk_i, pk_i \right>$ to allow secure communication between parties who never met. However, a trusted party is required which verifies the binding of an identity to a public key to prevent impersonation. The infrastructure authenticating all public key values is called the Public Key Infrastructure (PKI) as defined by Definition~\ref{def:pki}. However, PKI systems only shift the problem from trusting the users to trusting their keys. For example, if Eve could make the PKI system believe that her own public key $pk_{Eve}$ actually represents the public key of Alice $pk_{Alice}$, Eve would be able to read all Alice's confidential communication as she obviously has the private key $sk_{Eve}$ corresponding to $pk_{Eve}$. Therefore, it is important that public key systems rely on an architecture that authenticates whether key pairs belong to the claimed owner. In practice this is mostly achieved with the help of certification authorities or a web of trust.

\subsection{Certification Authorities}
In a traditional PKI system, all entities in the system trust a central party called the \textit{Certification Authority} (CA). It is the CA that guarantees public keys belong to the claimed owner. CA infrastructures are standardised in X.509~\cite{rfc4158}.

Suppose Alice wants to start using a key pair $\left< pk_A, sk_A \right>$, she has to authenticate herself with the CA by following correctly a protocol that confirms Alice's identity, usually over offline channels. Once Alice is authenticated with the CA, Alice sends the public key $pk_A$ to the CA along with a proof showing that Alice also owns the corresponding private key $sk_A$. This ''proof of correct possession'' often takes the form of a signature $S_{sk_A} \left( pk_A \right)$ generated by the private key $sk_A$ on the public key $pk_A$.

Once the CA is convinced of the authenticity of Alice's public key, it distributes a certificate approving that $pk_A$ effectively belongs to Alice. To avoid forged certificates, the CA signs Alice's certificate with its private key $sk_{CA}$. Anyone doubting the authenticity of the public key $pk_A$ can get convinced $pk_A$ effectively belongs to Alice by checking the signature of the CA with the CA's public key $pk_{CA}$.

In practice, CAs often approve the trustworthiness of other CAs by issuing certificates on their signing keys. In this way, often highly complex hierarchical architectures are achieved that boil down to the trust in one signing key of the highest authority. This puts heavy requirements on the CA's infrastructure as a compromised CA signing key can break the system completely. Indeed, a compromised signing key would allow to sign certificates of unauthenticated public keys or even certificates of public keys that belong to malicious entities.

If an entity's private key is lost or leaked to a third party, it can be revoked by the CA. CAs achieve this by periodic publication of \textit{revocation lists}. These revocation lists contain all compromised public keys. Consequently, users relying on a PKI should always verify these continuously growing lists before trusting a keypair. Thereby, revocation lists not only make the system less transparent, they also impose high demands on the infrastructure of entities relying on the PKI.

Suppose Alice's private key gets compromised due to Eve stealing her hard drive. Alice authenticates with the CA and sends a complaint stating her private key is no longer confidential. In return, the CA puts Alice's public key on the revocation list. The next time Bob wants to send a message to Alice, he first verifies the revocation list to conclude the last version of Alice's public key is no longer in use. However, the revocation list of the CA continuously grows with every additional hard drive Eve can steal thereby increasing the required time to download and verify the revocation list.

To partially get around the issue of revocation lists, certificates contain an expiration date. After expiration, a certificate should no longer be trusted. However, this requires keypair owners to contact CAs more frequently to sign new certificates each time the previous one has expired. Clearly, this puts a high computational demand on the authentication procedure of the CAs as well.

\subsection{OpenPGP and Web of Trust}
\label{sec:web_of_trust}
An alternative to the traditional PKI setting relying on CAs is a \textit{web of trust}. In a web of trust as originally proposed by Zimmerman, any entity can rate the trustworthiness of a public key. For example, if Bob receives Alice's public key personally during a date, the public key can be considered more trustworthy than when Bob receives Alice's key via e-mail. Web of trust systems allow users to vet for the authenticity other users' keys in the system. A standardised web of trust system is OpenPGP~\cite{rfc4880}.

The major advantage of a web of trust is that there no longer needs to be a CA with highly secure infrastructure as the publication of certificates now becomes a shared responsibility.

However, web of trust infrastructures present some issues, such as usability~\cite{art:WhittenT99}. In addition, users are now required to judge for themselves whether they can trust a public key or not. This gives more responsibility to users than most of them can handle without proper knowledge of the consequences to their actions.

\section{Identity-Based Encryption}
The concept of identity-based cryptography was proposed by Shamir~\cite{art:Shamir84} in 1984. In identity-based cryptography any string can be a valid public key for encryption or signature schemes thereby eliminating the need for digital certificates. Identity-based cryptography proves to be particularly elegant if the public key is related to an attribute that uniquely identifies the identity of the user like an e-mail address, an IP address or a telephone number. Consequently, identity-based cryptography reduces system complexity and the cost for establishing and managing the Public Key Infrastructure~(PKI)~\cite{art:BaekNSS04}. 


\subsection{Definition}
A generic Identity-Based Encryption (IBE) scheme is composed of four probabilistic polynomial time algorithms~\cite{art:BonehF01}:
\begin{description}
    \item[\texttt{IBE.Setup($1^{\lambda}$)}] On input of a security parameter $\lambda$, outputs a master secret $sk_{msk}$ and public parameters $params$.
    \item[\texttt{IBE.Extract($params, sk_{msk}, \id{}$):}] Takes public parameters $params$, the master secret $sk_{msk}$, and an \id{} as input and returns the private key $s_{\id{}}$ corresponding to the identity \id{}.
    \item[\texttt{IBE.Encrypt($params, \id{}, m$):}] Returns the encryption $c$ of the message $m$ on the input of the public parameters $params$, the \id{}, and the arbitrary length message $m$.
    \item[\texttt{IBE.Decrypt($s_{\id{}}, c$):}] Decrypts the ciphertext $c =$ \texttt{IBE.Encrypt}($params, \id{}, m$) back to the message $m$ on input of the private key $s_{\id{}}$ corresponding to the receiving identity \id{}.
\end{description}

\begin{figure}[ht]
    \begin{center}
    \scalebox{0.78}{
        \begin{tikzpicture}[auto, node distance=1mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=11mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            ]
            %\draw[help lines] (-6,-5) grid (8,3);
            \path
                % Images
                (-0.5,3) node [block] (pkg) {\includegraphics[scale=0.2]{img/pkg.png}}
                (-4,0) node [block] (alice) {\includegraphics[scale=0.2]{img/alice.png}}
                (4,0) node [block] (bob) {\includegraphics[scale=0.2]{img/bob.png}}
                % Text
                (-0.5, 0.5) node [leg, color=cyan] (c) {$c$}
                (1.5, 1.2) node [leg] (id_bob) {$s_{\id{Bob}}$}
                (4.3,2) node [leg] (bob_authenticates) {4. Bob authenticates as \id{Bob}}
                ;
                
       \node[below=of pkg] {\textbf{PKG}};
       \node[below=of alice] {\textbf{Alice} \\ 3. $c \leftarrow $\texttt{IBE.Encrypt($params, \id{Bob}, m$)}};
       \node[below=of bob] {\textbf{Bob} \\ 6. $m \leftarrow $\texttt{IBE.Decrypt($s_{\id{Bob}}, \id{Bob}, c$)}};
       \node[above=of pkg,align=left] {
               1. $\left< sk_{msk}, params \right> \leftarrow $\texttt{IBE.Setup($1^{\lambda}$)} \\
               2. publish $params$ \\
               \\
               5. $s_{\id{Bob}} \leftarrow $\texttt{IBE.Extract($params, sk_{msk}, \id{Bob}$)}
               };
       \begin{scope}[every path/.style=line]
        \path[color=cyan] (alice.east) -- (bob.west);
        \path (2.8,1) -- (1,2.2);
        \path (0.9,2.1) -- (2.7,0.9);
       \end{scope}


        \end{tikzpicture}
    }
    \end{center}
    \caption{Generic identity-based encryption scheme. The blue arrow denotes an insecure channel that can be eavesdropped.}
    \label{fig:generic_ibe_scheme}
\end{figure}

Figure~\ref{fig:generic_ibe_scheme} illustrates the IBE generic algorithms. A trusted Public Key Generator (PKG) generates a master private key $sk_{msk}$ and public parameters $params$ on input of the security parameter $\lambda$. Next, the PKG publishes the public parameters $params$ while storing $sk_{msk}$ preferably in encrypted format on a local disk. If Alice wants to send a message $m$ to Bob, it suffices for her to know the public parameters $params$ and the id $\id{Bob}$, uniquely identifying Bob. Then, Alice encrypts the message to a ciphertext $c$ that is sent over an insecure channel to Bob. On receipt of the ciphertext, Bob authenticates to the PKG over a secure channel to request his private key $sk_{\id{Bob}}$. Subsequently, the PKG generates the private key $sk_{\id{Bob}}$ corresponding to Bob's identity $\id{Bob}$ on input of the master secret key $sk_{msk}$, Bob's id $\id{Bob}$ and public parameters $params$. Subsequently, the PKG sends $sk_{\id{Bob}}$ back again over a secure channel. Bob has now all the required information to decrypt the ciphertext $c$ to its original plaintext message $m$.

\subsection{Comparison with PKI Schemes}
\label{sec:pros_and_cons_of_ibe}
Now we turn to overview the main advantages and disadvantages of generic IBE schemes when compared to more traditional PKI systems.

\subsubsection{Disadvantages}
\paragraph{Single point of failure:}
The PKG generates every private key $sk_{\id{}}$ in the system thereby creating a single point of failure. If a PKG disconnects due to an excessive amount of extraction requests, new users can no longer receive their private keys. However, users already owning a secret key can continue decrypting ciphertexts since this requires no additional communication with the PKG. A PKI system often consists of a hierarchy of CAs. Consequently, an offline CA only takes down a specific part of the PKI. However, an offline CA can no longer issue certificates either.

\paragraph{Key escrow:}
The PKG is required to be trusted since it learns $sk_{\id{}}$ for every entity in the system. A malicious PKG server could use this information to start eavesdropping on the insecure channel between Alice and Bob (the blue arrow in Figure~\ref{fig:generic_ibe_scheme}) while decrypting all ciphertexts that are being sent over. The undesired property that private keys have to be shared with a trusted third party is often called \textit{key escrow} in literature~\cite{art:AbelsonHARBMBJBMDWGJNGRLSISB97}. Since traditional PKIs only authenticate key pairs, key escrow is not an issue.

\paragraph{Revocation of public keys:}
Generic IBE schemes do not support revocation of public keys. However, Bob's private key $sk_{\id{Bob}}$ can still get compromised if he is careless with its storage. In fact, the research community has been focused on the revocation of IBE keys extensively~\cite{art:BoldyrevaGK12,art:BonehDTW01,art:HanaokaHSI05,art:LibertQ03}. Key revocation often requires additional infrastructure that complicates the elegancy of the currently proposed IBE scheme. The major drawback of revoking Bobs key is that Bob can no longer receive encrypted messages because his public key is part of his identity. Therefore, a pragmatic solution to this issue could be to append expiration dates to the public keys. Consequently, public keys will only be valid for a limited amount of time thereby restricting the damage that could be done with a compromised private key~\cite{art:BonehF01}. On the other hand, traditional PKIs publish revocation lists. Although these revocation list are a burden to the complexity of the PKI's infrastructure, they support a necessary feature for practical key management systems. 

\subsubsection{Advantages}
\paragraph{Complexity of the system:}
Only one PKG suffices to realise the IBE scheme, which relaxes expensive infrastructure requirements on the system. Due to the support of revocation lists and the often hierarchical organisation, PKI systems are complex structures with a high amount of redundancy.

\paragraph{User friendliness:}
Users who have no background on cryptographic primitives no longer have to make conscious decisions on key lengths or the randomness of their keys. In an IBE system a public key is a string available to anyone in the system. This is generally conceived as more transparent to users lacking a background on cryptography. An average user knows what a username or an e-mail address represents and to whom it belongs while an authenticated public key is generally not a familiar concept.

\paragraph{Opt-in by default:}
Another useful property of an IBE scheme is that a recipient is not required to actively subscribe to a hierarchy of CAs neither a web of trust before a sender can start sending him messages. In this way, the possibility to send encrypted messages becomes inherently part of any system in which the users are assigned unique identifiers. This is particularly useful in systems where the majority of the users has no knowledge about cryptographic primitives. Users do no longer need to generate a key pair neither subscribe to a third party infrastructure. It suffices to recall how their connections can be uniquely identified in the system to learn their public keys.

\subsection{Security of IBE}
IBE schemes follow similar security notions as generic public key systems. Therefore, definitions of security are often subtle as different levels of security can be distinguished. In literature, the security notions mostly considered are \textit{indistinguishability under chosen plaintext attack} (IND-CPA) and \textit{indistinguishability under chosen ciphertext attack} (IND-CCA). Anonymity of the encryption scheme is an additional property of the scheme that is often desired~\cite{art:BellareBDP01}.

For a more in depth discussion on IND-CPA and IND-CCA, the reader is referred to Boneh and Franklin~\cite{art:BonehF01}, whereas for a more formal description of ciphertext anonymity the reader is referred to Abdalla et al.~\cite{art:AbdallaBCKKLMNPS05}.

\subsubsection{Indistinguishability Under Chosen Plaintext Attack}
Indistinguishability under chosen plaintext attack (IND-CPA) is described by the negligible advantage an adversary has in trying to distinguish which of both given plaintext messages $m_0$ and $m_1$ generated a ciphertext $c$. It captures the notion of \textit{semantic security}, i.e. that any ciphertext $c$ should not give more information about the original plaintext $m$ than any other random binary string of the same length.

IND-CPA is best defined with the help of a game that challenges the adversary. The advantage of the adversary in winning the IND-CPA game illustrated in Game~\ref{game:ind_cpa_game}, is defined as
\begin{equation*}
 Adv = \lvert \textrm{Pr} \left[ b = b' \right] - \frac{1}{2} \rvert
\end{equation*}

If the adversary has negligible advantage trying to win the IND-CPA game, the IBE system is said to be IND-CPA secure. More formally, an IBE system is IBE-IND-CPA secure if for every adversary with advantage $Adv$ in winning the IBE-IND-CPA game illustrated in Game~\ref{game:ind_cpa_game} there exists a negligible function $\mu \left( \lambda \right)$ such that $Adv \leq \mu \left( \lambda \right)$.

\begin{game}
\caption{Generic IBE-IND-CPA Game~\cite{thesis:Alfredo08}}
\label{game:ind_cpa_game}
\begin{description}
 \item \textbf{Goal}: An adversary is challenged by a game to check the IND-CPA security of an IBE scheme.
 
 \item \textbf{Result}: This IBE-IND-CPA Game helps to define the concept of IND-CPA security for IBE schemes.
\end{description}

 \begin{enumerate}
  \item The challenger runs $\left< sk_{msk}, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:firs_oracle_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a private key $sk_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, sk_{msk}, \id{}$)} corresponding to an adversary defined identity $\id{i}$.
  \item The adversary picks two equal length plaintext messages $m_0$ and $m_1$ and an identity $\id{encrypt}$. The adversary honestly passes $\left< m_0, m_1, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and executes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{encrypt}, m_b$)}. The challenger gives $c$ to the adversary.
  \item \label{item:second_oracle_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. If $b \neq b'$ or if the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:firs_oracle_query} or step~\ref{item:second_oracle_query}, the adversary loses the game.
 \end{enumerate}
\end{game}

\subsubsection{Indistinguishability Under Chosen Ciphertext Attack}
Indistinguishability under chosen ciphertext (IND-CCA) is a more demanding level of security. Therefore, an algorithm that is IND-CCA secure is considered more secure than an IND-CPA secure algorithm. IND-CCA security implies that an adversary has no advantage in trying to distinguish which of both given plaintext messages $m_0$ and $m_1$ generated a ciphertext $c$ even if the adversary has access to a list of (plaintext, ciphertext)-tuples.

IND-CCA is defined with the help of a game that challenges an adversary similar to the IND-CPA game. Compared to the IND-CPA game, the IND-CCA game contains two additional steps in which the adversary gets access to another oracle. %If the adversary has negligible advantage trying to win the IND-CCA game from Game~\ref{game:ind_cca_game}, the IBE system is said to be IND-CCA secure. 
The advantage of the adversary in winning the IND-CCA game illustrated in Game~\ref{game:ind_cca_game}, is defined as
\begin{equation*}
 Adv = \lvert \textrm{Pr} \left[ b = b' \right] - \frac{1}{2} \rvert
\end{equation*}

If the adversary has negligible advantage trying to win the IND-CCA game, the IBE system is said to be IND-CCA secure. More formally, an IBE system is IBE-IND-CCA secure if for every adversary with advantage $Adv$ in winning the IBE-IND-CCA game illustrated in Game~\ref{game:ind_cca_game} there exists a negligible function $\mu \left( \lambda \right)$ such that $Adv \leq \mu \left( \lambda \right)$.

In literature a distinction is often made between a \textit{non-adaptive} case (IND-CCA1) and an \textit{adaptive} case (IND-CCA2) of IND-CCA. In the non-adaptive case, step 6 from Game~\ref{game:ind_cca_game} is not allowed. More precisely, an IBE scheme that satisfies Game~\ref{game:ind_cca_game} is said to be IND-CCA2 secure.

\begin{game}
\caption{Generic IBE-IND-CCA Game~\cite{thesis:Alfredo08}}
\label{game:ind_cca_game}
\begin{description}
 \item \textbf{Goal}: An adversary is challenged by a game to check the IND-CCA security of an IBE scheme.
 
 \item \textbf{Result}: This IBE-IND-CCA Game helps to define the concept of IND-CPA security for IBE schemes.
\end{description}

 \begin{enumerate}
  \item The challenger runs $\left< sk_{msk}, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:cca_first_oracle_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a private key $sk_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, sk_{msk}, \id{}$)} corresponding to an adversary defined identity $\id{i}$.
  \item \label{item:cca_first_decryption_query} The adversary can start querying another oracle $O_{Decrypt} \left( sk_{\id{i}}, c_j \right)$ that returns a plaintext $m_j \leftarrow$ \texttt{IBE.Decrypt($sk_{\id{i}}, c_j$)} corresponding to an adversary defined ciphertext $c_j$ and identity $\id{i}$.
  \item The adversary picks two equal length plaintext messages $m_0$ and $m_1$ and an identity $\id{encrypt}$. The adversary honestly passes $\left< m_0, m_1, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and executes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{}, m_b$)}. The challenger gives $c$ to the adversary.
  \item \label{item:cca_second_oracle_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item \label{item:cca_second_decryption_query} The adversary continues querying the oracle $O_{Decrypt} \left( sk_{\id{i}}, c_j \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. Otherwise, the adversary loses the game. If the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:cca_first_oracle_query} or step~\ref{item:cca_second_oracle_query} or if the adversary queried the oracle $O_{Decrypt} \left( sk_{\id{i}}, c_j \right)$ with $c_j = c$ during step~\ref{item:cca_first_decryption_query} or step~\ref{item:cca_second_decryption_query}, the adversary loses the game as well.
 \end{enumerate}
\end{game}

\subsubsection{Anonymous Identity-Based Encryption}
An IBE scheme is called anonymous (ANO-IBE) when the ciphertext does not leak the identity of the recipient. In the overview illustrated in Figure~\ref{fig:generic_ibe_scheme}, this implies that no eavesdropper on the insecure channel between Alice and Bob could derive that Bob is the recipient based on the information in the ciphertext $c$ alone~\cite{art:BoyenW06}.

ANO-IBE is defined with the help of a game that challenges an adversary similar to the IND-CPA game. Similar to IND-CCA and IND-CPA security, an IBE system is said to be anonymous if the adversary has negligible advantage trying to win the ANO-IBE game in Game~\ref{game:ano_ibe}. Again, the advantage of the adversary in winning the IND-CCA game illustrated in Game~\ref{game:ind_cca_game}, is defined as
\begin{equation*}
 Adv = \lvert \textrm{Pr} \left[ b = b' \right] - \frac{1}{2} \rvert
\end{equation*}

More formally, an IBE system is ANO-IBE secure if for every adversary with advantage $Adv$ in winning the ANO-IBE game illustrated in Game~\ref{game:ano_ibe} there exists a negligible function $\mu \left( \lambda \right)$ such that $Adv \leq \mu \left( \lambda \right)$.

Gentry~\cite{art:Gentry06} presents the first scheme which combines the notions of IND-CPA and IND-CCA with ANO-IBE. Therefore, a system is then said to be IND-ANO-CPA secure or IND-ANO-CCA secure if it satisfies a modified version of the game in Game~\ref{game:ano_ibe}. For a more detailed discussion on the topic the reader is referred to the original paper~\cite{art:Gentry06}.

\begin{game}
\caption{Generic ANO-IBE Game~\cite{thesis:Alfredo08}}
\label{game:ano_ibe}
\begin{description}
 \item \textbf{Goal}: An adversary is challenged by a game to check the ANO-IBE security of an IBE scheme.
 
 \item \textbf{Result}: This ANO-IBE Game helps to define the concept of ANO-IBE security for IBE schemes.
\end{description}
 \begin{enumerate}
  \item The challenger runs $\left< sk_{msk}, params\right> \leftarrow$ \texttt{IBE.Setup($1^{\lambda}$)} and returns $params$ to the adversary.
  \item \label{item:first_ano_query} The adversary can start querying an oracle $O_{Extract} \left( \id{i} \right)$ that returns a private key $sk_{\id{i}} \leftarrow$ \texttt{IBE.Extract($params, sk_{msk}, \id{i}$)} corresponding to an adversary defined identity $\id{i}$.
  \item The adversary picks a plaintext message $m$ and an identity \id{encrypt}. The adversary honestly passes $\left< m, \id{encrypt} \right>$ to the challenger.
  \item The challenger picks a random bit $b$ and computes \\ $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{encrypt}, m$)} if $b=0$. If $b=1$, the challenger computes $c \leftarrow$ \texttt{IBE.Encrypt($params, \id{encrypt}, r$)} where $r$ is a random bit sequence with the same length as the message $m$. The challenger gives $c$ to the adversary.
  \item \label{item:second_ano_query} The adversary continues querying the oracle $O_{Extract} \left( \id{i} \right)$ adaptively.
  \item The adversary outputs a bit $b'$ based on the ciphertext $c$. If $b = b'$ the adversary wins the game. If $b \neq b'$ or if the adversary queried the oracle $O_{Extract} \left( \id{i} \right)$ with $\id{i} = \id{encrypt}$ during step~\ref{item:first_ano_query} or step~\ref{item:second_ano_query}, the adversary loses the game.
 \end{enumerate}
\end{game}

% Uiteenzetting hoe we tot BF-IBE DKG komen:
%    -> BF-IBE is anoniem, BB is NIET anoniem
%            => zie winter lecture op 
%                  https://www.youtube.com/watch?v=Tt7cJnZDth0&index=8&list=PLXF_IJaFk-9C4p3b2tK7H9a9axOm3EtjA
%    -> SK-IBE en BB vereisen communicatie tussen DKGs
%       tijdens extractie stap.
%    -> SK-IBE berust op BDHI veronderstelling = niet leuk
%    -> BB is vorm van HIBE => totaal aantal gebruikers moet op voorhand worden vastgelegd = niet leuk
%    -> BB is enkel selective-ID CCA secure = niet leuk
\subsection{Overview}
\label{sec:evolution_of_ibe}
Although Shamir~\cite{art:Shamir84} easily constructed an identity-based signature scheme based on RSA in 1984, the practical use of IBE remained an open problem until the introduction of bilinear maps. Boneh and Franklin~\cite{art:BonehF01} proposed the first practically usable IBE scheme based on the Weil pairing, however, the security proof still relies on the random oracle assumption. At the same time, Sakai and Kasahara~\cite{art:SakaiOK01} proposed a different IBE scheme independently from Boneh and Franklin. The scheme from Sakai and Kasahara initially received less attention, because the original presentation is in Japanese and lacking a security proof. Subsequently, Sakai and Kasahara~\cite{art:SakaiK03} proposed an extended version of their original scheme which is proven to be IND-CCA secure in the random oracle model by Chen et al.~\cite{art:ChenC05} 

Canetti et al.~\cite{art:CanettiHK03} introduced the first secure IBE scheme without relying on the random oracle model. Nevertheless, the attacker model in~\cite{art:CanettiHK03} requires the adversary to declare upfront which identity \id{} is targeted during step 5 of the CCA Game (Algorithm~\ref{game:ind_cca_game}) and step 4 of the CPA Game. Therefore, the scheme by Boneh and Franklin~\cite{art:BonehF01} is considered more secure as attackers can adaptively choose the targeted identity. Later, Boneh and Boyen~\cite{art:BonehB04} presented a variant to~\cite{art:CanettiHK03} which also realises only selective ID security.

Waters~\cite{art:Waters05} is the first to present a scheme that is IND-CCA secure in the standard model. Drawback of the scheme from Waters~\cite{art:Waters05} is that it requires large public parameters. Gentry~\cite{art:Gentry06} proposes a more efficient alternative to this scheme in the standard model while achieving shorter public parameters. However, the scheme from Gentry relies on a complicated hardness assumption called q-BDHE. It is only after the introduction of the Dual System paradigm by Waters~\cite{art:Waters09} in 2009 that IND-CCA security can be achieved in the standard model based on reasonable assumptions. De Caro et al.~\cite{art:CaroIP10} are the first to define an IND-ANO-CCA secure IBE scheme on the Dual System construction of Waters~\cite{art:Waters09}. % Note that paper from Lewko and Waters only considers HIBE and no IBE scheme.

Although all these references contributed to the evolution of IBE, not all of these schemes are ANO-IBE. The IBE scheme from Boneh and Franklin~\cite{art:BonehF01} is IND-ANO-CCA secure since IBE systems in the random oracle model are ANO-IBE. In the standard model, it appeared to be harder to construct ANO-IBE schemes at first sight, e.g. it can be proven that the scheme from Boneh and Boyen~\cite{art:BonehB04} is not anonymous in its original form. The scheme from Gentry~\cite{art:Gentry06} was the first anonymous IBE scheme in the standard model. Boyen and Waters~\cite{art:BoyenW06} published almost synchronously another IBE scheme in the standard model that is also IND-ANO-CCA secure. In 2010, Ducas~\cite{art:Ducas10} showed that even schemes that were first considered not anonymous like the one from Boneh and Boyen~\cite{art:BonehB04} but also~\cite{art:BonehBG05,art:Waters05} can be proven anonymous when relying on asymmetric pairings thereby making anonymity a more common property in IBE schemes.

\subsection{Most Attractive IBE Schemes}
In the standard model mainly the anonymous IBE constructions from Gentry~\cite{art:Gentry06} and De Caro et al.~\cite{art:CaroIP10} have the most satisfying properties. However, IBE constructions in the standard model often come at the cost of higher computational requirements~\cite{art:Boyen08}. Certainly the scheme from De Caro demands a higher amount of computational resources since it relies on composite order groups. Although methods~\cite{art:Freeman10,art:Lewko12} have been developed to convert IBE schemes from composite order groups to single order prime groups, these methods do not apply to the scheme from De Caro et al.~\cite{art:LeeL10}

From all schemes discussed in Section~\ref{sec:evolution_of_ibe} the ones initially developed by Boneh and Franklin~\cite{art:BonehF01} and Sakai and Kasahara~\cite{art:SakaiK03} are the most attractive ones in the random oracle model because of their anonymity and non-selective security. Consequently, it is not a coincidence that both schemes have found description in an informational RFC document. Sakai and Kasahara IBE is described in RFC 6508~\cite{rfc6508} and RFC 6509~\cite{rfc6509}. Boneh and Franklin IBE can be found in RFC 5409~\cite{rfc5409}. 

The ANO-IND-CCA secure scheme from Boneh an Franklin~\cite{art:BonehF01} is included in Algorithm~\ref{alg:full_indent} since it is valuable for the remainder of the text.

%\begin{algorithm}
%\caption{IND-ANO-CPA Boneh and Franklin IBE~\cite{art:BonehF01}}
%\label{alg:basic_indent}
%\begin{description}
% \item \textbf{Goal}: Alice wants to send an IBE encrypted message to Bob.
 
% \item \textbf{Result}: Alice sends an IBE encrypted ciphertext $c$ that is successfully decrypted by Bob.
%\end{description}
% \begin{enumerate}
%  \item \texttt{Setup($1^{\lambda}$)}: Let $\lambda$ be the security parameter for a security level of $l$ bits.
%  \begin{enumerate}
%   \item Execute setup algorithm $\left< q, G_1, G_2, e: G_1 \times G_2 \rightarrow G_T, P \in G_1 \right> \leftarrow \mathcal{G} \left( 1^{\lambda} \right)$ to generate the parameters
%    \begin{enumerate}
%     \item A large prime $q$
%     \item Gap groups $G_1$ and $G_2$ of order $q$
%     \item An admissible bilinear map $e: G_1 \times G_2 \rightarrow G_T$
%     \item A random generator $P \in G_1$
%   \end{enumerate}
%   \item Choose a uniformly random $sk_{msk} \in \mathbb{Z}^{*}_q$ and calculate
%   \begin{equation*}
%    P_{pub} = sk_{msk} P
%   \end{equation*}
%   \item Choose cryptographic hash functions
%    \begin{enumerate}
%     \item $H_1: \{ 0,1  \}^* \rightarrow G_1$
%     \item $H_2: G_2 \rightarrow \{ 0,1 \}^l$
%    \end{enumerate}
%  \end{enumerate}
%  \item \texttt{Extract($params, sk_{msk}, \id{}$)}:
%   \begin{enumerate}
%    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right) \in G_1$
%    \item Set the private key of $\id{}$ to $sk_{\id{}} = sk_{msk} Q_{\id{}}$
%   \end{enumerate}
%   \item \texttt{Encrypt($params, \id{}, m$)}:
%   \begin{enumerate}
%    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right)$
%    \item Choose a random $r \in Z_q$
%    \item Encrypt the plaintext message $m$ to the ciphertext $c$ as
%    \begin{equation*}
%     c = \left< rP, m \oplus H_2 \left( g_{\id{}^r} \right) \right> = \left< U, v \right> \; \; \textrm{with} \; \; g_{\id{}} = e \left( Q_{\id{}}, P_{pub} \right) \in G_T
%    \end{equation*}
%   \end{enumerate}
%   \item \texttt{Decrypt($sk_{\id{}}, c$)}: Decrypt the ciphertext $c$ back to the plaintext message $m$ as
%   \begin{equation*}
%    m = v \oplus H_2 \left( e \left( sk_{\id{}}, U \right) \right)
%   \end{equation*}
% \end{enumerate}
%\end{algorithm}
%\makebox[10cm][s]{

\afterpage{ % execute argument of this command *after* end of current page
\clearpage
\begin{algorithm}
\caption{IND-ANO-CCA Boneh and Franklin IBE~\cite{art:BonehF01}}
\label{alg:full_indent}
 \textbf{Goal}: Alice wants to send an IBE encrypted message to Bob. \\
 \textbf{Result}: Alice sends an IBE encrypted ciphertext $c$ that is successfully decrypted by Bob.
 \begin{enumerate}
  \item \texttt{Setup($1^{\lambda}$)}: 
  \begin{enumerate}
   \item Execute setup algorithm $\left< q, G_1, G_2, e: G_1 \times G_2 \rightarrow G_T, P \in G_1 \right> \leftarrow \mathcal{G} \left( 1^{\lambda} \right)$ to generate the parameters
    \begin{enumerate}
     \item A large prime $q$
     \item Gap groups $G_1$ and $G_2$ of order $q$
     \item An admissible bilinear map $e: G_1 \times G_2 \rightarrow G_T$
     \item A random generator $P \in G_1$
   \end{enumerate}
   \item Choose a uniformly random $sk_{msk} \in \mathbb{Z}^{*}_q$ and compute $P_{pub} = sk_{msk} P$

   \item Choose cryptographic hash functions
    \begin{enumerate}
     \item $H_1: \{ 0,1  \}^* \rightarrow G_1$
     \item $H_2: G_2 \rightarrow \{ 0,1 \}^l$
     \item $H_3: \{ 0,1 \}^l \rightarrow \left( 0,1 \right)^l$
    \end{enumerate}
  \end{enumerate}
  \item \texttt{Extract($params, sk_{msk}, \id{}$)}:
   \begin{enumerate}
    \item Compute $Q_{\id{}} = H_1 \left( \id{} \right) \in G_1$
    \item Set the private key of $\id{}$ to $sk_{\id{}} = sk_{msk} Q_{\id{}}$
   \end{enumerate}   \item \texttt{Encrypt($params, \id{}, m$)}:
   \begin{enumerate}
    \item Compute $Q_{\id{}} = H_1 \{ \id{} \}$
    \item Choose a random $sigma \in \left( 0,1 \right)^l$
    \item Compute $r = H_3 \{ sigma, m \}$
    \item Encrypt the plaintext message $m$ to the ciphertext $c$ as
    \begin{equation*}
     \begin{split}
      c = \left< rP, sigma \oplus H_2 \left( g_{\id{}}^r\right), m \oplus H_3 \left( sigma \right) \right> = \left< U, v, w \right> \\ 
     \; \; \textrm{with} \; \; g_{\id{}} = e \left( Q_{\id{}}, P_pub \right) \in G_T
     \end{split}
    \end{equation*}
   \end{enumerate}
   \item \texttt{Decrypt($sk_{\id{}}, c$)}: Decrypt the ciphertext $c$ back to the plaintext message $m$ as follows
   \begin{enumerate}
    \item Compute $sigma = v \oplus H_2 \left( e \left( sk_{\id{}}, U \right) \right)$
    \item Compute $m = w \oplus H_3 \left( sigma \right)$
    \item Set $r = H_3 \left( sigma, m \right)$. Test that $U = rP$. If not, reject the ciphertext.
    \item Output $m$ as the decryption of $c$
    \end{enumerate}
 \end{enumerate}
\end{algorithm}
\clearpage
}

\section{Broadcast Encryption}
Another relevant aspect of encryption in OSNs is how one encrypted message can be securely broadcasted to multiple users. To this means, broadcast encryption (BE) was introduced by Fiat and Naor~\cite{art:FiatN93}, as a public-key generalisation to a multi user setting. In particular, a BE scheme allows a user to encrypt a message $m$ to a subset $\mathcal{S}$ of users in a public key system, such that, only users in the set $\mathcal{S}$ are able to decrypt the message. The computational overhead of a BE is generally bound to the ciphertext and the number of recipients.

\subsection{Definition}
A generic Broadcast Encryption (BE) scheme is composed of four probabilistic polynomial time algorithms:

\begin{description}
    \item[\texttt{BE.Setup($1^{\lambda}$)}]: On input of a security parameter $\lambda$, generates the public parameters $params$ of the system.
    \item[\texttt{BE.KeyGen($params$)}]: Returns the public and private key ($pk_i,sk_i$) for each user $i$ while taking the public parameters $params$ into account.
    \item[\texttt{BE.Encrypt($m, \mathcal{S}$)}]: Takes a set of public key values $\mathcal{S}=\{pk_i \ldots pk_{|\mathcal{S}|}\}$ corresponding to users $i$ in the system along with a plaintext message $m$ to generate a corresponding ciphertext $c$.
    \item[\texttt{BE.Decrypt($c, sk_i$):}] Reconstructs $m$ from $c$ using the private key $sk_i$ if the corresponding public key $pk_i \in \mathcal{S}$. Otherwise, return $\bot$.
\end{description}

Note that this definition is stated generically enough to allow all kinds of public keys to be used. Therefore, not only traditional PKIs can benefit from BE schemes, but also IBE schemes in which a public identifier \id{i} serves as a public key $pk_i$.

\subsection{Overview}
\label{sec:evolution_of_be}
The issue of encrypting one message to reach multiple recipients has been widely studied in literature since its first introduction by Fiat and Naor~\cite{art:FiatN93}. This section highlights the most important evolutions of BE in literature, however it only considers the most relevant publications to our goal: achieving user-friendly broadcast encryption for OSNs.

\subsubsection{Broadcast Encryption}
The implementation from Fiat and Naor~\cite{art:FiatN93} requires a ciphertext of size  $O \left( t \log^2 t \log n \right)$ to be~secure against $t$ colluding users. The first fully collusion resistant scheme was proposed by Naor et al.~\cite{art:NaorNL01} thereby making the ciphertext size independent of the number of colluding users. A collusion resistant BE scheme refers to a broadcast encryption scheme that is secure even if all users that are not in the recipient set $\mathcal{S}$ would collaborate. Halevy and Shamir~\cite{art:HalevyS02} further reduce the required ciphertext length for collusion resistant schemes followed by many~\cite{art:DodisF02,art:GoodrichST04,art:LewkoSW08} achieving ciphertext sizes only dependent on the number of revoked users $O \left( r \right)$. Boneh, Gentry and Waters~\cite{art:BonehBG05} are the first to consider utilisation of bilinear maps to realise constant size ciphertexts and $O \left( n \right)$ public keys.

\subsubsection{Identity-Based Broadcast Encryption}
Sakai and Furukawa are the first to define a collusion resistant identity based broadcast encryption (IBBE) scheme in~\cite{art:SakaiF07}. Independently, Delerabl\'{e}e~\cite{art:Delerablee07} realises a similar IBBE scheme and claims to be the first as well.  The size of the public key in both schemes is proportional to the maximum size of the intended set of recipients while realising short ciphertexts and private keys. 

Baek et al.~\cite{art:BaekNSS04} defines an IBBE scheme that requires only one pairing computation, proven secure under the random oracle assumption where the attacker ties himself to a selective-ID attack. Later, Gentry and Waters achieve identity based broadcast encryption with sublinear ciphertexts in~\cite{art:GentryW08}. Their scheme is proven secure against the stronger notion of adaptive security where the attacker can adaptively alter its queries depending on earlier received information. Barbosa and Farshim~\cite{art:BarbosaF05} proposed an identity-based key encapsulation scheme for multiple parties which is an extension of \textit{mKEM} as considered by Smart~\cite{art:Smart04} to the identity-based setting. An mKEM is a Key Encapsulation Mechanism which takes multiple public keys as input. An encrypted message under mKEM consists of an encapsulated session key $k$ and a symmetric encryption $E_k \left( m \right)$ of the plaintext message $m$ under $k$. However, the scheme from Smart~\cite{art:Smart04} is only proven secure under the random oracle assumption.

\subsubsection{Anonymous Broadcast Encryption}
\label{sec:anobe}
All earlier mentioned references describing BE require the intended set of recipients to be published to realise higher efficiency. Barth, Boneh and Waters~\cite{art:BarthBW06} are the first to design a BE scheme that takes the anonymity of the recipient into account.
\begin{defn}[Anonymity]
\label{def:anonymity}
 A BE scheme is said to be \textit{anonymous} if it hides who is included in the recipient set $\mathcal{S}$. That is, no entity inside or outside $\mathcal{S}$ can derive the identity of recipients included in $\mathcal{S}$ from the broadcasted ciphertext.
\end{defn}

The proposed anonymous broadcast encryption (ANOBE) scheme  from Barth, Boneh and Waters~\cite{art:BarthBW06} implies a linear dependency of the ciphertext on the number of recipients and can only be proven secure in the random oracle model. In~\cite{art:LibertPQ12} Libert et al., propose an alternative ANOBE scheme that is proven secure in the standard model. Both~\cite{art:BarthBW06} and~\cite{art:LibertPQ12} propose a tag based system that allows efficient decryption at the cost of making the public master key linear dependent on the total number of users. Krzywiekci et al.~\cite{art:KrzywieckiKK06} propose a scheme that is proportional to the number of revoked users, although the security proof is rather informal. In~\cite{art:YuRL10}, Yu et al. design an architecture that even hides the number of users in the recipient set using Attribute Based Encryption (ABE)~\cite{art:SahaiW04}.

However, ABE requires that all users are assigned attributes such that all users who have sufficient attributes in common can decrypt the message. In networks where the total number of users is large it can be a work intensive task to label each user with the correct attributes.

\subsubsection{Outsider-Anonymous Broadcast Encryption}
The notion of outsider anonymous broadcast encryption is introduced by Fazio and Perera~\cite{art:FazioP12}.
\begin{defn}[Outsider Anonymity]
\label{def:outsider_anonymity}
 A BE scheme is called \textit{outsider anonymous} if the identities of the recipients are known to the other identities in the recipient set $\mathcal{S}$ while remaining secret to other parties of the BE scheme.
\end{defn}

The scheme from Fazio and Perera~\cite{art:FazioP12} relies on IBE to encode where a recipient is positioned in a publicly published tree to achieve sublinear ciphertexts. It is remarkable that sublinear ciphertexts are achieved while attaining recipient anonymity to all users that are outside the intended set of receivers. However, the scheme has the drawback of immediately fixing the total number of users that are allowed in the system. Furthermore, an additional architecture is required to maintain the tree of subscribed users. Although IBE is used, the scheme does not allow to represent public keys of users by their public identifiers, because the public key needs to be the position of a user in the tree structure of the external architecture. In this way, most of the desirable properties of IBE cancel out. Although the scheme from Fazio and Perera does not fit the requirements for user-friendly broadcast-encryption in OSNs, it is useful to remember their definition of outsider-anonymity.

\subsection{Most Attractive BE Schemes}
From the aforementioned schemes the one from Libert et al.~\cite{art:LibertQ03} contains the most attractive properties as it is proven secure in the standard model at almost no reduced computational efficiency. The scheme supports anonymity in both identity-based BE as well as traditional asymmetric cryptosystems.

If anonymity is not an issue, different BE schemes have to be considered depending on the goals of the target application. The scheme from Libert et al.~\cite{art:LibertPQ12} certainly does not have the most desirable properties in non-anonymous BE environments since it can not benefit from higher efficiency due to the recipient being publicly known.

\section{Secret Sharing}
In 1979, both Shamir~\cite{art:Shamir79} and Blakley~\cite{art:Blakley79} independently proposed an algorithm achieving perfect threshold secret sharing.

\begin{defn}[Secret Sharing Scheme]
\label{def:secret_sharing_scheme}
 A \textit{Secret Sharing Scheme} is a cryptographic scheme that divides a secret $s$ into $n$ pieces of data $\sigma_1, \ldots, \sigma_n$ called \textit{shares}. Shares are distributed over $n$ different parties called \textit{shareholders} such that only specific subsets of the distributed shares allow reconstruction of the original secret $s$.
\end{defn}

\begin{defn}[Threshold scheme]
\label{def:threshold_scheme}
 A $\left( t, n \right)$ \textit{threshold scheme} $\left( t \leq n \right)$ is a secret sharing scheme by which a trusted party securely distributes $n$ different shares $\sigma_i$ to $n$ different parties $P_i$ for $1 \leq i \leq n$ such that any subset of $t$ or more different shares $\sigma_i$ easily allows to reconstruct the original secret $s$. Knowledge of $t-1$ or less shares is insufficient to reconstruct the original secret $s$.
\end{defn}

\begin{defn}[Perfect threshold scheme]
\label{def:threshold_scheme}
 A $\left( t, n \right)$ threshold scheme is said to be \textit{perfect} if no subset of fewer than $t$ shareholders can derive any partial information in the information theoretic sense about the original secret $s$ even with infinite computational resources.
\end{defn}

Shamir's solution~\cite{art:Shamir79} was based on polynomial interpolation while Blakley's algorithm~\cite{art:Blakley79} relied on finite geometries. Blakley secret sharing uses more bits than necessary as it describes multidimensional planes. In contrast, Shamir secret sharing requires as many bits for each share as the length of the original secret.


\begin{algorithm}
\caption{Shamir's $\left( t, n \right)$ threshold scheme~\cite{book:handbook_of_applied_cryptography} }
\label{alg:shamirs_threshold_sheme}
\begin{description}
 \item \textbf{Goal}: A dealer $D$ distributes shares of a secret $s$ to $n$ parties.
 
 \item \textbf{Result}: If a subset of at least $t$ out of $n$ shareholders collaborates, they can reconstruct the original secret $s$.
\end{description}

 \begin{enumerate}
  \item \textit{Setup} A dealer $D$ begins with a secret integer $s \geq 0$ it wishes to distribute among $n$ parties
   \begin{enumerate}
    \item $D$ chooses a prime $p > \max \left( s, n \right)$ and defines $a_0 = s$
    \item $D$ selects $t-1$ random, independent coefficients $a_1, \ldots, a_{t-1}, 0 \leq a_j \leq p-1$ defining the random polynomial over $\mathbb{Z}_p$, $f \left( x \right) = \sum^{t-1}_{j=0} a_j x^j$
    \item $D$ computes $\sigma_i = f \left( i \right) \bmod p, 1 \leq i \leq n$ and securely transfers the share $\sigma_i$ to shareholder $P_i$, along with a public index $i$.
   \end{enumerate}
   \item \textit{Reconstruction} Any group of $t$ or more shareholders pool their shares. Their shares provide $t$ distinct points $\left( x, y \right) = \left( i, \sigma_i \right)$ allowing computation of the coefficients $a_j, 1 \leq j \leq t-1$ of $f \left( x \right)$ by Lagrange interpolation. The secret is recovered by calculating
 \begin{equation*}
  f \left( 0 \right) = \sum^t_{i=1}y_i b_i = s \; \; \; \textrm{with} \; \; \; b_i = \prod_{1 \leq j \leq t, j \neq i} \frac{j}{j-i}
 \end{equation*}
 \end{enumerate}
\end{algorithm}

The idea behind Shamir secret sharing is elegant in its simplicity. Shamir secret sharing is based on the principal that any polynomial $f \left( x \right)$ of degree $t-1$ is uniquely defined by $t$ points lying on the polynomial. For example, it is possible to draw only one straight line between 2 different coordinates, a quadratic is fully defined by 3 different coordinates and so on. If the trusted party randomly generates a polynomial of degree $t-1$ it suffices to securely distribute one of $n$ different coordinates on the curve to each party $P_i, 0 \leq i \leq n$. A subset of at least $t$ different shareholders has to collaborate in order to reconstruct the original polynomial by interpolation. For security reasons the polynomial $f \left( x \right)$ is calculated in a finite field modulo a large prime number $p$. The complete mechanism of Shamir's threshold scheme is depicted in Algorithm~\ref{alg:shamirs_threshold_sheme}. The mechanism behind reconstruction in Algorithm~\ref{alg:shamirs_threshold_sheme} is explained because the coefficients of an unknown polynomial $f \left( x \right)$ of degree less than $t$, defined by points $\left( x_i, y_i \right), 1 \leq i \leq t$ are given by the Lagrange interpolation formula
\begin{equation*}
 f \left( x \right) = \sum^t_{i=1}y_i b_i \; \; \; \textrm{with} \; \; \; b_i = \prod_{1 \leq j \leq t, j \neq i} \frac{x-x_j}{x_i-x_j}
\end{equation*}
A proof of this formula is omitted but can be found in~\cite{site:proofwiki_lagrange}.

\subsection{Verifiable Secret Sharing}
Verifiable secret sharing~\cite{art:ChorGMA85} tries to ensure the participating parties that received shares are consistent by providing a verification mechanism. This verification mechanism can either detect an unfair dealer during setup or participants submitting incorrect shares during the reconstruction phase. The first verifiable secret sharing schemes were \textit{interactive}, i.e. interaction between shareholders and the trusted party was required to verify their shares. In \textit{non-interactive verifiable secret sharing} as proposed by Pedersen~\cite{art:Pedersen91} only the trusted party is allowed to send messages to the future shareholders. Shareholders can not communicate with each other neither can they send messages back to the trusted party. Non-interactive verifiable secret sharing is preferred over interactive alternatives as their is no chance of shareholders accidentally leaking too much information.

Popular verifiable secret sharing schemes are Feldman's scheme~\cite{art:Feldman87} and Benaloh's scheme~\cite{art:Benaloh86a}. No further details are given as a basic notion of verifiable secret sharing suffices for the remainder of this text.

\section{Distributed Key Generation}
\label{sec:distributed_key_generation}
Distributed key generation is inspired on secret sharing. The idea behind distributed key generation is that a secret $s$ can be shared among $n$ shareholders without the requirement for a centralised dealer $D$ as in Algorithm~\ref{alg:shamirs_threshold_sheme}. In this way, a secret can be negotiated between all shareholders without any of the shareholders explicitly computing the secret. The major advantage of such a scheme is that no party in the scheme requires a higher level of trust since no party explicitly knows the secret. Similarly to the Shamir secret sharing scheme a group of $t$ or more shareholders will need to pool their shares in order to reconstruct the secret $s$.

\subsection{Definition}
\begin{defn}[Distributed key generation scheme]
\label{def:dkg_scheme}
 A \textit{distributed key generation scheme} is a $\left( t,n \right)$ perfect threshold scheme $\left( t \leq n \right)$ that requires no trusted party. That is, a distributed key generation scheme is a cryptographic scheme that negotiates a secret $s$ with $n$ different parties $P_1, \ldots, P_n$ by letting each party $P_i$ distribute shares $\sigma_{ij}$ of its own private secret $\sigma_i$ with all other parties $P_j$ where $1 \leq i \leq n, 1 \leq j \leq n$. At least $t$ out of $n$ parties will need to collude in order to compute the original secret $s$ explicitly.
\end{defn}

\subsection{Pedersen Distributed Key Generation}
The first usable distributed key generation protocol was defined by Pedersen~\cite{art:Pedersen91a}. A later publication from Gennaro et al.~\cite{art:GennaroJKR07} proves the Pedersen scheme to be insecure in its original form in the presence of malicious key generation centers.

Although the Pedersen scheme~\cite{art:Pedersen91a} is proven insecure, it is most instructive to describe the protocol in its original form as later schemes such as the one from Gennaro et al.~\cite{art:GennaroJKR07} extensively rely on the same concepts. Therefore, the original Pedersen protocol is shown in Algorithm~\ref{alg:pedersen_dkg}. 

The correctness of the Pedersen scheme is based on every party $P_i$ correctly executing a Shamir $\left( t, n \right)$-threshold scheme. After every party has distributed its shares, each party $P_i$ owns $n$ points $\left( i, f_j \left( i \right) \right) = \left( i, \sigma_{ji} \right)$ from other parties $P_j$. By summation of all these shares $s_i = \sum_{j \in \mathcal{Q}} \sigma_{ji} \bmod p$, $s_i$ represents the $y$-coordinate corresponding to $x=i$ of the sum of all curves $f_j \left( x \right)$ generated by all parties $P_j$. In this way, the negotiated master secret key $sk_{msk}$ is equal to the sum of the secret keys of every party $P_i$, such that
 \begin{equation*}
  sk_{msk} = \sum_{i \in \mathcal{Q}} sk_i \bmod p
 \end{equation*}
In fact the master secret key $sk_{msk}$ is found by summing all private curves $f_j \left( x \right)$ such that every honest party's share equally contributes to the master secret key $sk_{msk}$.

The other steps in the Pedersen protocol are required to verify whether all parties calculate the shares honestly. Step e) verifies the correctness of the received shares. Therefore, the $A_{jh}$ values are often called Pedersen commitments. 

The scheme from Gennaro et al.~\cite{art:GennaroJKR07} lets each party $P_i$ commit to two different curves since a flaw in the Pedersen scheme allows malicious parties to determine certain bits in $sk_{msk}$ with non-negligible advantage. The details behind the scheme from Gennaro et al. are omitted since more practical DKG protocols in the asynchronous setting are already presented such as in a publication by Kate and Goldberg~\cite{art:KateHG12}.

\begin{algorithm}
\caption{Pedersen's distributed key generation~\cite{art:Pedersen91a}}
\label{alg:pedersen_dkg}
\begin{description}
 \item \textbf{Goal}: A master secret key $sk_{msk}$ is negotiated with $n$ uniquely numbered parties $\{ P_1, \ldots, P_n \}$ without any of the parties explicitly computing the secret $sk_{msk}$.
 
 \item \textbf{Result}: If a subset of at least $t$ out of $n$ parties colludes, they can reconstruct the original secret $s$.
\end{description}
 \begin{enumerate}
  \item \textit{Setup} At initialisation, a setup algorithm $\left< p, g \right> \leftarrow \mathcal{G} \left( 1^{\lambda} \right)$ is executed that returns a large prime number $p$ and a generator $g$ of $\mathbb{Z}_p$ on input of a security parameter $\lambda$. After execution of $\mathcal{G} \left( 1^{\lambda} \right)$ each party $P_i, 1 \leq i \leq n$ should do the following:
   \begin{enumerate}
    \item $P_i$ generates a random private key $sk_i \in \mathbb{Z}_p$ and publishes the corresponding public key $pk_i = g^{sk_i}$
    \item $P_i$ chooses $t-1$ random independent coefficients $a_{i,1}, \ldots, a_{i,t-1}, 0 \leq a_{i,j} \leq p-1$ defining a random polynomial $f_i \left( x \right)$ over $\mathbb{Z}_p$, $f_i \left( x \right) = \sum^{t-1}_{h=0} a_{i,h} x^h$.
    \item $P_i$ commits to the coefficients $a_{i,1}, \ldots, a_{i,t-1}, 0 \leq a_{i,h} \leq p-1$ by broadcasting $A_{ih} = g^{a_{i,h}} \bmod p$ for $h = 1, \ldots, t$ to all other parties.
    \item $P_i$ computes the share $\sigma_{ij} = f_i \left( j \right) \bmod p$ and securely transfers the share $\sigma_{ij}$ to party $P_j$ along with a signature $S_{P_i} \left( \sigma_{ij} \right)$ authenticating the share. $P_i$ keeps $\sigma_{ii}$ to itself.
    \item $P_i$ verifies for each share $\sigma_{ji}$ received from $P_j$ whether it is consistent by verifying that
    \begin{equation*}
     g^{\sigma_{ji}} = \prod_{h=0}^{n-1} \left( A_{jh} \right)^{i^h} \bmod p
    \end{equation*}
    If the check fails for an index $j$, $P_i$ broadcasts a complaint against $P_j$ along with the received share $\sigma_{ji}$ and its signature $S_{P_j} \left( \sigma_{ij} \right)$. If a party receives $t$ complaints, he is excluded from the set of participating parties $\mathcal{Q}$.
    \item The master public key is calculated as $pk_{msk} = \prod_{j \in \mathcal{Q}} pk_j \bmod p$. The public verification values are calculated as $A_h = \prod_{j \in \mathcal{Q}}A_{jh} \bmod p$ for $k=1, \ldots, t$. Each player $P_i$ sets his share of the secret as $s_i = \sum_{j \in \mathcal{Q}} \sigma_{ji}$.
   \end{enumerate}
   \item \textit{Reconstruction} Any group of $t$ or more shareholders pool their shares. Their shares provide $t$ distinct points $\left( x, y \right) = \left( i, s_i \right)$ allowing computation of the coefficients $a_j, 1 \leq j \leq t-1$ of $f \left( x \right)$ by Lagrange interpolation. The master secret key is recovered by calculating
   \begin{equation*}
    sk_{msk} = \sum_{i \in \mathcal{Q}} s_i b_i \quad \textrm{with} \quad b_i = \prod_{i \in \mathcal{Q}, i \neq h} \frac{h}{h-i}
   \end{equation*}
 \end{enumerate}
\end{algorithm}

\section{Summary}
The aforementioned cryptographic building blocks are all there is required to design a practical encryption scheme for OSNs in Chapter~4.

This chapter started with the introduction of Public Key Infrastructures (PKIs). In a next section, Identity-Based Encryption (IBE) was presented as a possible alternative to traditional PKIs. In addition, the basics of Broadcast Encryption (BE) were highlighted. Finally, secret sharing and Distributed Key Generation (DKG) were introduced as a mechanism to get around the IBE key escrow property.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
