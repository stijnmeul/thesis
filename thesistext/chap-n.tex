\chapter{Implementation}
\label{cha:n}

% Wat moet er in dit hoofdstuk staan?
%%%%%% Implementatiedetails van het schema
% Welk sociaal netwerk? 
% Gebruikt Authenticated Encryption scheme
% Keylengths
% Welke elliptische curve?
% Hoe worden random getallen gekozen?

%%%%%% Architectuur van de implementatie
% Kijk naar figuur van de hummingbirdpaper
%%%% Implementatie aan client side
% Structuur van de code
% Encountered issues
%%%% Implementatie DKG
%% Structuur van de code
%% Encountered issues
% MIRACL is niet parallelliseerbaar

%%%%% Future work
% DKGs praten in plain text
% Aanvraag van de secret key gebeurt nu zonder authenticatiemechanisme
%%%%% Opgelet voor
% Javascript leest input uit
% User mag geen recipient set via de OSN specifiÃ«ren
% Gebruikers die reageren op statussen worden wel plots bekend uit de recipient set => mogelijke workaround is om hele conversatie weg van het sociaal netwerk te laten gebeuren => op die manier drijf je steeds verder af van het oorspronkelijk sociaal netwerk
% Receivers die het sociaal contract breken
% Fake profielen kunnen worden aangemaakt door gebruikers

\section{Software Architecture}
There is still a long way to go from Algorithm~\ref{alg:our_scheme} towards a practical implementation for OSNs. As a proof of concept, Algorithm~\ref{alg:our_scheme} is applied to Facebook, the largest online social network at the time of writing. Recall that one of the more general goals of this thesis is to develop a solution that is applicable, i.e. a solution that does not require the OSN environment to be altered. Until so far this goal is successfully met since Algorithm~\ref{alg:our_scheme} could be designed completely based on a more general model for OSNs. The resulting algorithm is a solution that can be applied to virtually any OSN that allows to uniquely distinguish users based on unique public identifiers, a requirement that discriminates almost no existing OSNs.

\subsection{Software Environment}
Despite the avoidance of complex third party infrastructures, some software is needed that effectively implements Algorithm~\ref{alg:our_scheme} in a user-friendly way. Ideally, this is an easy-to-install piece of software that runs as an additional layer on top of the current infrastructure of the OSN user. Therefore, it was chosen to implement Algorithm~\ref{alg:our_scheme} in the form of a browser extension.

Since Scramble~\cite{art:BeatoKW11} already has a user friendly interface that supports all required use cases to implement encryption on OSNs, it is natural to integrate our IBE scheme into Scramble. Besides from Scramble being open source and lightweight, the most important trigger to modify the existing Scramble code is that it is developed at KU Leuven.

\subsection{Existing Environment}
Recall from Section~\ref{sec:existing_solutions} that Scramble~\cite{art:BeatoKW11} is a Firefox extension that currently relies on OpenPGP~\cite{rfc4880} for key management. Due to the dependency on OpenPGP, Scramble is independent of any OSN. In fact, Scramble only functions as an encryption and decryption tool that can be used on any website offering users to submit content. However, users who want to be part of the recipient set of the uploaded messages need to have uploaded a public key to the OpenPGP network beforehand. The existing Scramble environment is shown in Figure~\ref{fig:original_scramble_arch}.

Since Scramble is a FireFox extension, the user interface (UI) is implemented in Javascript. Although Javascript is ideal for synchronous UIs, it is not the desired programming language for computational demanding tasks such as encryption and decryption. Therefore, Scramble communicates with a back-end in Java that implements all cryptographic operations. Every time a user selects a computation intensive task in the Javascript UI, Javascript sends an XML message requesting the result from the client side Java back-end. The Java back-end processes the request and immediately sends the result in another XML message back to the UI. Sending and receiving of XML messages between FireFox extension and Java back-end, takes place synchronously over a socket listening on an internal port.

Scramble relies on OpenPGP for key management. Therefore, the FireFox extension communicates with a web of trust (Section~\ref{sec:web_of_trust}) storing all public keys of users who subscribed to the OpenPGP network. Because the OpenPGP network stores more keys than a Scramble user needs, Scramble offers the functionality to store public keys from the OpenPGP network locally in a contact database via the client side Java back-end. Furthermore, the client-side Java back-end has access to an encrypted list of the user's secret keys corresponding to public keys that are already in the OpenPGP network. With the help of a passphrase the Java back-end has access to these private keys to allow encryption of received messages.


\begin{figure}
    \begin{center}
    \noindent\makebox[\textwidth]{
        \scalebox{0.72}{
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray},
            ]
            
            % Client side polygon
            \draw[dashed] (-9,4) -- (-1,4) -- (-1,-4.25) -- (-9,-4.25) -- (-9,4);
            % OSNs Polygon
            \draw[dashed] (0,4) -- (5,4) -- (5,1.4) -- (0,1.4) -- (0,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-14,4) -- (-10,4) -- (-10,-2) -- (-14,-2) -- (-14,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (1.5,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (2.5,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                (-5,2.5) node [block2] (ffext) {Scramble FireFox Extension}
                (-5,0) node [block2] (csback) {Client Side Java Back-end}
                (-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-7,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-12,2.5) node [block2] (pgp) {OpenPGP}
                (-12,-0.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (pkstor) {Public Key Storage}

                
                % Text
                (-5,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (2.5,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-3.5,1.15) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-8.5,2.8) node [leg,font=\small,fill=white] (white_block) {OpenPGP Messages}
                (-12,4) node [leg,fill=white] (white_block) {\textbf{Web of Trust}}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (csback.north);
        \path (csback.south east) -- (db.north);
        \path (ffext.west) -- (pgp.east);
        \path (ffext.east) -- (0,2.5);
        \path (keystor.north) -- (csback.south west);
        \path (pkstor.north) -- (pgp.south);
       \end{scope}

        \end{tikzpicture}
        }
    }
    \end{center}
    \caption{Original Scramble Architecture}
    \label{fig:original_scramble_arch}
\end{figure}

\subsection{Changes to the Existing Environment}
The altered Scramble architecture is schematically illustrated in Figure~\ref{fig:new_scramble_arch}. Scramble still offers the original functionality as an alternative to our IBE implementation. However, for reasons of conciseness Figure~\ref{fig:new_scramble_arch} omits the original OpenPGP implementation although it is not removed.


\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.72} {
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray},
            ]
            
            % Client side polygon
            \draw[dashed] (-5.5,4) -- (-0.4,4) -- (-0.4,-4.5) -- (-5.5,-4.5) -- (-5.5,4);
            % OSNs Polygon
            \draw[dashed] (0.5,4) -- (5.5,4) -- (5.5,1.4) -- (0.5,1.4) -- (0.5,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-11.5,4) -- (-6.5,4) -- (-6.5,-7) -- (-11.5,-7) -- (-11.5,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1.5,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (2.25,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3.75,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (3,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4.5,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                %(-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-9,2.5) node [block2] (dkgfront) {PKG Website (PHP Front-end)}
                (-9,-2.5) node [block2] (dkgback) {PKG C++ MIRACL Based Back-end}
                (-9,0) node [block2] (dkgcfront) {PKG Socket (C++ Front-end)}

                
                % Text
                (-3,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (3,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-9,4) node [leg,fill=white] (white_block) {\textbf{Server Side PKG}}
                (-9,-5.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystorcs) {Encrypted Key Storage}
                (-1.65,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-7.75,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-6,3.15) node [leg,font=\small,fill=white] (white_block) {XML \\ Messages over \\ POST Request}
                (-12,0.5) node [leg,font=\small,fill=white] (white_block) {XML Messages \\ to Other PKGs}
                
                (-3,2.5) node [block2] (ffext) {Scramble FireFox Extension}
                (-3,0) node [block2] (csback) {Client Side C++ MIRACL Based Back-end}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (csback.north);
        %\path (csback.south) -- (db.north);
        \path (ffext.west) -- (dkgfront.east);
        \path (ffext.east) -- (0.5,2.5);
        \path (dkgcfront.north) -- (dkgfront.south);
        \path (csback.south) -- (keystorcs.north);
        \path (dkgback.north) -- (dkgcfront.south);
        \path (keystor.north) -- (dkgback.south);
        \path (dkgcfront.west) -- (-13.5,0);
       \end{scope}

        \end{tikzpicture}
        }
    }

    \caption{New Scramble Architecture}
    \label{fig:new_scramble_arch}
\end{figure}


The new client side Scramble architecture implements a C++ based back-end instead of the earlier Java back-end because the most efficient pairing-based multi precision libraries are written in C. In fact only two pairing-based libraries are widely accepted in practical implementations: MIRACL~\cite{art:Scott03} and PBC~\cite{thesis:Lynn07}. MIRACL was preferred over PBC since it is generally faster in its pairing computations. All core algorithms of MIRACL are implemented in C while a C++ wrapper allows object-oriented programming.

The contact database is removed from the original Scramble implementation as illustrated in Figure~\ref{fig:original_scramble_arch} since public keys no longer have to be explicitly stored in the architecture. More specifically, since Scramble can rely on IBE, the public keys are inherently part of the supported OSN. Therefore, the FireFox extension falls back on a number of calls to supported OSN APIs in order to get all public keys of one's connections.

Figure~\ref{fig:new_scramble_arch} exchanges the web of trust from Figure~\ref{fig:original_scramble_arch} for a DKG infrastructure in order to support IBE without key escrow. For clarity, only one PKG is shown since all PKGs will have the same structure. The PKG supports two front-ends: a C++ based front-end and a PHP based front-end. 

The C++ based front-end of the PKG only serves as a front-end during execution of the DKG protocol. Negotiation of the shares is implemented over synchronous sockets. At the startup of the PKG socket, the administrator is asked for a secret passphrase. Then, the sockets start listening on a predetermined port until all shares are correctly negotiated. Once all PKGs have exchanged their shares, the PKG calculates its public parameters and finishes the \texttt{Setup} step from Algorithm~\ref{alg:our_scheme}. The coefficients of the secret polynomial are encrypted with the earlier specified passphrase along with the negotiated secret share. After storage of these secret parameters, the C++ socket starts listening on another port to handle requests from the PHP front-end. Handling of private key extraction requests is multithreaded to handle requests of multiple clients at the same time.

The PHP based front-end receives private key extraction queries from the Scramble FireFox extension in the form of POST requests. The PKG communicates the requested $\id{}$ to the listening C++ socket in the form of an XML message. After the required MIRACL based pairing computations, the PKG socket sends the response back to the PHP webpage such that it is published in the form of an XML message over HTTPS~\cite{rfc2818}.

Note that the new architecture from Figure~\ref{fig:new_scramble_arch} can be applied to virtually any OSN that identifies its users with publicly available identifiers. However, Scramble is made more user friendly by implementing OSN specific API calls. Currently, an implementation for Facebook serves as a proof-of-concept. Further extension to support other OSNs could be subject of future work.


\section{Implementation Details}
\label{sec:implementation_details}
The implementation of Algorithm~\ref{alg:our_scheme} still requires some practical design decisions that are further discussed in this section.

\subsection{Type of Elliptic Curve}
The underlying elliptic curve determines the groups of the bilinear pairing $e: G_1 \times G_2 \rightarrow G_T$ and thus the security level of the application. The MIRACL library supports 5 different curves and 6 different security levels. However, the Barreto-Lynn-Scott (BLS) curve~\cite{art:BarretoLS02} is preferred since it provides the highest level of security in MIRACL. BLS curves rely on Ate pairings~\cite{art:HessSV06} with an embedding degree of 24. Consequently, BLS curves are considered suitable for a security level of 256 bits.

\subsection{Authenticated Encryption Scheme}
An AES-GCM~\cite{art:McGrewV04} implementation is used for the authenticated encryption scheme in Algorithm~\ref{alg:our_scheme} since it is one of the more efficient authenticated encryption schemes unencumbered by patents. The AES-GCM implementation as provided by MIRACL is used with authentication tags of 128 bits. Apart from a symmetric key of 128, 192 or 256 bits, AES-GCM also requires an Initialisation Vector (IV). The recommended length of the IV is 96 bits because it can be handled more efficiently~\cite{rfc5084}.

\subsection{Key Lengths}
Since the maximum level of security in MIRACL is determined by the BLS curve, all implemented key lengths in Algorithm~\ref{alg:our_scheme} follow from the 256 bits security level ($l=256$). Note that in Step 1 of \texttt{Retrieve} the decryption of a recipient's session key is calculated as: 

\begin{equation*}
 w_i \oplus H_2 \left( e \left( s_{\id{i}}, U \right) \right) = \rho
\end{equation*}
followed by
\begin{equation*}
 v \oplus H_3 \{ \rho \} = k
\end{equation*}
with
\begin{equation*}
 H_2: G_T \rightarrow \{ 0,1 \}^{l}
\end{equation*}
Since $l=256$, $w_i$ and $\rho$ are binary sequences of 256 bits. Hence, $\rho$ only contains sufficient randomness to securely encrypt a session key $k$ of the same length. The full 256 bit $k$ is not completely used for symmetric encryption as the AES-GCM scheme still requires an IV as well. Since the randomness and key freshness of the IV is at least as important as the secrecy of $k$~\cite{nist:dworkin}, it was deliberately chosen not to apply key derivation functions to derive a separate symmetric encryption key and IV from the same value $k$. Therefore, the first 128 bits of $k$ are used as the symmetric key of AES-GCM, while the second 96 bits function as an IV. According to NIST, this should ensure confidentiality at least until 2030. However, if a higher level of security should be required, key derivation on $k$ could be considered.

\subsection{Hash Functions}
The hash function $H_1: \{ 0,1 \}^{*} \rightarrow G_1$ is implemented using the MIRACL function call \texttt{hash\textunderscore to\textunderscore group}. Hash function $H_2: G_T \rightarrow \{ 0,1 \}^{256}$ relies on the MIRACL\texttt{hash\textunderscore to\textunderscore aes\textunderscore key} function. Both $H_1$ and $H_2$ internally fall back on SHA-256~\cite{nist:fips1804}. The MIRACL provided SHA-256 algorithm is also used for implementation of the hash $H_3: \{ 0, 1 \}^{256} \rightarrow \{ 0,1 \}^{256}$.

\subsection{Generating Random Numbers}
Random numbers are generated using the MIRACL build-in strong random number generator. The strong random generator is initialised with a time-of-day value and a binary array of 1024 bits read from \texttt{/dev/urandom}. These values are then used as a seed for the generation of random numbers. The practical implementation of the MIRACL strong random generator is based on an advice published by RSA Laboratories in~\cite{art:Matthews96}.

\subsection{Public Key}
The decision on which string to use as a public IBE key \id{} is dependent on the underlying OSN. The desired properties for \id{} are the following:
\begin{enumerate}
 \item The public key should uniquely identify the user
 \item The public key should be mandatory for every user of the social network
 \item The public key should not change frequently over time
 \item The public key should be an inherent part of the infrastructure of the social network thereby meaning that the previous three properties are already ensured by the provider of the social network.
 \item The public key should be publicly available, even to users that are not part of the set of entities with access to the user's profile $\mathcal{V}_{\id{}}$
\end{enumerate}
In Facebook the best key satisfying these properties is a Facebook username. A Facebook username is ensured to be unique since it is part of a profile's URL, e.g. \url{http://www.facebook.com/profile.name} where \texttt{profile.name} functions as \id{}. Moreover, the Facebook policy ensures that this username is mandatory for every user and can only be changed once. Lastly, the Facebook username is also public to outsiders using the Facebook API thereby fulfilling all the required conditions for an IBE key in our architecture.

\section{Implemented Scheme}

\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.55} {
        \begin{tikzpicture}
        
        % BroadcastMessage
        \begin{abstractclass}[text width =7.5 cm]{BroadcastMessage}{2,2}
          \attribute{\# recipients : vector\textless  string\textgreater}
          \attribute{\# message : string }
          \attribute{\# autData : AuthenticatedData *}
          \attribute{\# sessionKey : char[HASH\textunderscore LEN]}
          \operation{\# void getIV(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{\# void getK(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{+ int getNbOfRecipients()}
          \operation[0]{+ string getMessage()}
          \operation{+ int getBroadcastMessageLength()}
          \operation{+ Big getSessionKey()}
        \end{abstractclass}
        
        % PlaintextMessage
        \begin{class}[text width =9 cm]{PlaintextMessage}{ -4 , -9}
          \inherit{BroadcastMessage}
          \attribute{- r : Big}
          \attribute{- recipientHashes : vector\textless G1\textgreater }
          \attribute{- sigma : Big}
          \operation{+ PlaintextMessage(string message)}
          \operation{+ void addRecipient(string recipient, PFC *pfc)}
          \operation{+ EncryptedMessage encrypt(const G2\& P, const G2\& Ppub, PFC *pfc)}
          \operation{+ string getMessage()}
          \operation{+ vector <string> getRecipients()}
          \operation{- generateKeys(PFC *pfc)}
        \end{class}
        
        % EncryptedMessage
        \begin{class}[text width =9 cm]{EncryptedMessage}{7 , -9}
          \inherit{BroadcastMessage}
          \attribute{- A : char *}
          \attribute{- Alen : int}
          \attribute{- C : char *}
          \attribute{- Clen : int}
          \attribute{- T : char[TAG\textunderscore LEN]}
          \operation{+ EncryptedMessage(string encryptedMessage)}
          \operation{+ PlaintextMessage decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id, PFC *pfc )}
          \operation{+ string getMessage()}
        \end{class}
        
        %AuthenticatedData
        \begin{class}[text width =8 cm]{AuthenticatedData}{-9 , 2}
          \inherit{BroadcastMessage}
          \attribute{- authenticatedData : char *}
          \attribute{- U : G2}
          \attribute{- ws : vector<Big>}
          
          \operation{+ AuthenticatedData(char * A)}
          \operation{+ G2 getU()}
          \operation{+ void setU(G2 U)}
          \operation{+ int getNbOfRecipients()}
          \operation{+ vector\textless Big\textgreater getEncryptedRecipientKeys()}
          \operation{+ int getLength(int nbOfRecipients)}
          \operation{+ void add(Big encryptedRecipientKey)}
          \operation{+ void encodeTo(char * array)}
        \end{class}
        \unidirectionalAssociation {AuthenticatedData}{part of}{1}{BroadcastMessage}
        \end{tikzpicture}
    }}
    \caption{Class Diagram of Client Side C++ MIRACL Based Back-end}
    \label{fig:class_client_side}
\end{figure}
\subsection{Client-Side Implementation}
\subsubsection{Code Structure}
\textcolor{red}{TODO: give a short description on what each function implements}

\subsubsection{Encountered Issues}
\textcolor{red}{TODO: Say something about pre-computation in MIRACL and why the const G2\& is necessary.}

\subsection{Server-Side Implementation}

\subsubsection{Code Structure}
\textcolor{red}{TODO: Add a class diagram for the server-side implementation}

\textcolor{red}{TODO: give a short description on what each function implements}

\subsubsection{Encountered Issues}
\textcolor{red}{TODO: Say something about the difficulties of multithreading MIRACL}

\section{Performance Analysis}
Performance experiments were conducted on an Intel Core 2.4 GHz i5 processor with 8 Gb of 1600 MHz DDR3L onboard memory. Table~\ref{table:performance_of_proposed_scheme} illustrates the  execution times for Algorithm~\ref{alg:our_scheme} with the implementation details from Section~\ref{sec:implementation_details}. 

Encryption times are linearly dependent on the number of intended recipients since more intensive pairing computations are required for each additional user within the recipient set.

Each recipient has to decrypt $w_i$ an average of $\eta/2$ times to retrieve the secret session key $k$. However, the experiments measured the worst-case execution time for decryption since the recipient had to decrypt all $w_i$ values before retrieving $k$ in the last attempt. After recovering $k$, the recipient executes AES-GCM for the decryption of the ciphertext $c$ to the plaintext message $m$. Note that recipient anonymity of $\mathcal{S}$ comes at the cost of reduced efficiency, as to hide $\mathcal{S}$ it is required to produce more \texttt{IBE.Encrypt} calls.

\textcolor{red}{TODO: Add another table listing how much time each step of Algorithm~\ref{alg:our_scheme} requires.}

\begin{table}
  \centering
  \begin{tabular}{@{}lrr@{}} \toprule
    \multicolumn{3}{r}{Execution Times (ms)} \\ \cmidrule(r){2-3}
    Number of Recipients & Encryption & Decryption \\ \midrule
    1 & 284.5 & 275.4  \\
    % 5 & 1278.750 \ms & 357.302 \ms \\
    10 & 2564.5  & 460.9  \\
    15 & 3799.6  & 560.6  \\
    % 20 & 5029.470 \ms & 657.030 \ms \\
    % 25 & 6258.510 \ms & 761.765 \ms \\
    50 & 12300.5  & 1237.8  \\
    100 & 25867.7  & 2260.2  \\  \bottomrule
  \end{tabular}
  \caption{Performance of the proposed scheme in function of the number of intended recipients.}
  \label{table:performance_of_proposed_scheme}
\end{table}

\section{Shortcomings of Current Implementation}
The algorithm as it is currently implemented only serves as a proof-of-concept since it lacks a number of requirements needed for secure use in practice. These aspects were not implemented due to the limited time available. Although all core requirements for the protocol in Algorithm~\ref{alg:our_scheme} are present, only the aspects for practical usage in more hostile environments are missing. However, including these aspects should be straightforward and is only a matter of implementation instead of deliberate design decisions.

\subsection{Client Side}
Since the IBE scheme is integrated in the existing Scramble UI, not many adaptions should be made to the client side implementation. The major drawback of our IBE proposal is that it makes the Scramble plugin more dependent on the underlying OSN. Consequently, every OSN should be separately integrated into the Scramble plugin since each OSN offers its own API calls for reading out friend connections. More OSNs than Facebook should be actively supported by the IBE Scramble tool to motivate the use of the plugin.

\subsection{Server Side}
In its present form, the PKG is only simulated in a local environment. Therefore, it suffices to rely on synchronous communication over C++ sockets each listening on a different port. However, before adaption to a world-wide DKG network is possible, the protocol should take more asynchronous aspects into account such as connection-loss, DOS-attacks or undelivered packets. Kate et al.~\cite{art:KateHG12} propose a more advanced DKG protocol in the asynchronous setting that could be adapted for our IBE setting.

Since the DKG protocol is currently always simulated in a local environment, all PKG sockets communicate their XML messages in plain text. More secure socket protocols should be considered such as SSL~\cite{rfc6101} for adoption to a more hostile distributed setting.

Furthermore, the current assumptions on the PKGs (Section~\ref{sec:assymptions_on_pkg}) are too severe for practical environments. In practice the current Pedersen DKG scheme~\cite{art:Pedersen91a} is insecure and is better replaced by the one from Gennaro et al.~\cite{art:GennaroJKR07}. If all mentioned updates on the current server side scheme are effectively achieved, more relaxed assumptions on the PKG are in place. With less stringent PKG assumptions, the DKG network could even be partially supported by the OSN providers to show their good intensions of making their networks more private.

\subsection{Shortcomings Effecting Both Client and Server}
Currently, private key extraction takes the form of a POST request over HTTPS~\cite{rfc2818}. Although the PKGs publish the response in plain text to their PHP website, the communication is encrypted by a self-signed SSL certificate. Ideally, this certificate is signed by a world-wide trusted CA such that the client-side implementation can effectively verify whether it is communicating with a valid PKG.

Although web communication between the client side Scramble tool and the server side PKG is already encrypted, a client can request the private key parameters for every $\id{}$ since there is no authentication mechanism checking the user's identity. However, Facebook provides third party authentication in its API. If a Facebook login dialogue is integrated in the Scramble UI, the returned Facebook authentication token serves as a proof to the PKG that the requester of the private key resembles the owner of the corresponding Facebook profile.

\section{Summary}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
