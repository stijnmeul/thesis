\chapter{Implementation}
\label{cha:n}
To show the viability of our solution, Algorithm~\ref{alg:our_scheme} is implemented on Facebook, currently the OSN with the largest total number of users on the internet. The user interface of our implementation relies on Scramble, an existing open-source Firefox plugin for broadcast encryption on OSNs.

The structure of this chapter is as follows. The different components in the existing Scramble architecture are highlighted before turning to adaptation of the existing architecture (Section~\ref{sec:software_architecture}). Next, a discussion follows on how the practical details of the cryptographic building blocks and parameters from Algorithm~\ref{alg:our_scheme} are implemented (Section~\ref{sec:implementation_details}). Furthermore, the structure of our code along with encountered implementation issues is described (Section~\ref{sec:implemented_code}). This is concluded by a performance analysis (Section~\ref{sec:performance_analysis}) and a list of limitations of our current implementation (Section~\ref{sec:limitations_of_implementation}).
% Wat moet er in dit hoofdstuk staan?
%%%%%% Implementatiedetails van het schema
% Welk sociaal netwerk? 
% Gebruikt Authenticated Encryption scheme
% Keylengths
% Welke elliptische curve?
% Hoe worden random getallen gekozen?

%%%%%% Architectuur van de implementatie
% Kijk naar figuur van de hummingbirdpaper
%%%% Implementatie aan client side
% Structuur van de code
% Encountered issues
%%%% Implementatie DKG
%% Structuur van de code
%% Encountered issues
% MIRACL is niet parallelliseerbaar

%%%%% Future work
% DKGs praten in plain text
% Aanvraag van de secret key gebeurt nu zonder authenticatiemechanisme
%%%%% Opgelet voor
% Javascript leest input uit
% User mag geen recipient set via de OSN specifiÃ«ren
% Gebruikers die reageren op statussen worden wel plots bekend uit de recipient set => mogelijke workaround is om hele conversatie weg van het sociaal netwerk te laten gebeuren => op die manier drijf je steeds verder af van het oorspronkelijk sociaal netwerk
% Receivers die het sociaal contract breken
% Fake profielen kunnen worden aangemaakt door gebruikers

\section{Software Architecture}
\label{sec:software_architecture}
The high level structure of the current Scramble implementation is presented along with the required changes to adapt it for our IBE architecture.

\subsection{Software Environment}
Despite the avoidance of complex third party infrastructures, some software is needed that effectively implements Algorithm~\ref{alg:our_scheme} in a user-friendly way. Ideally, this is an easy-to-install piece of software that runs as an additional layer on top of the current infrastructure of the OSN user. Therefore, it was chosen to implement Algorithm~\ref{alg:our_scheme} in the form of a browser extension.

Since Scramble~\cite{art:BeatoKW11} already has a user friendly interface that supports all required use cases to implement encryption on OSNs, it is natural to integrate our IBE scheme into Scramble. Besides from Scramble being open source and lightweight, the most important trigger to modify the existing Scramble code is that it is developed at KU Leuven~\footnote{The scramble code can be downloaded at \url{https://www.cosic.esat.kuleuven.be/scramble/}}.

\subsection{Existing Environment}
\begin{figure}
    \begin{center}
    \noindent\makebox[\textwidth]{
        \scalebox{0.66}{
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray!40},
            ]
            
            % Client side polygon
            \draw[dashed] (-9,4) -- (-1,4) -- (-1,-5.75) -- (-9,-5.75) -- (-9,4);
            % OSNs Polygon
            \draw[dashed] (0,4) -- (5,4) -- (5,1.4) -- (0,1.4) -- (0,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-14,4) -- (-10,4) -- (-10,-2) -- (-14,-2) -- (-14,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (1.5,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (2.5,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                (-5,2.5) node [block2] (ffext) {Scramble Firefox Extension}
                (-5,0) node [block2] (javasocket) {Local Java Socket}
                (-5,-2) node [block2] (csback) {Client Side Java Back-end}
                (-3,-4.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-7,-4.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-12,2.5) node [block2] (pgp) {OpenPGP}
                (-12,-0.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (pkstor) {Public Key Storage}

                
                % Text
                (-5,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (2.5,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-3.5,1.15) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-8.5,2.8) node [leg,font=\small,fill=white] (white_block) {OpenPGP Keys}
                (-12,4) node [leg,fill=white] (white_block) {\textbf{Web of Trust}}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (javasocket.north);
        \path (javasocket.south) -- (csback.north);
        \path (csback.south east) -- (db.north);
        \path (ffext.west) -- (pgp.east);
        \path (ffext.east) -- (0,2.5);
        \path (keystor.north) -- (csback.south west);
        \path (pkstor.north) -- (pgp.south);
       \end{scope}

        \end{tikzpicture}
        }
    }
    \end{center}
    \caption{Original Scramble Architecture}
    \label{fig:original_scramble_arch}
\end{figure}
\enlargethispage{\baselineskip}
Scramble~\cite{art:BeatoKW11} is a Firefox extension that relies on OpenPGP~\cite{rfc4880} for encryption, access control and key management. Due to the use of OpenPGP, Scramble works independent of the underlying OSN. In fact, Scramble functions as an encryption and decryption tool for any website offering users the possibility to submit content. However, users who want to be part of the recipient set of the uploaded messages need to upload a public key to the OpenPGP network beforehand. The architecture overview of the Scramble environment is illustrated in Figure~\ref{fig:original_scramble_arch}.

Since Scramble is a Firefox extension, the user interface (UI) is implemented in Javascript. Although Javascript is ideal for synchronous UIs, it is not the desired programming language for computational demanding tasks such as encryption and decryption. Therefore, Scramble communicates with a back-end in Java that implements all cryptographic operations. Every time a user selects a computation intensive task in the Javascript UI, the Firefox extension sends an XML message requesting the result from the client side Java back-end. The Java back-end processes the request and immediately sends the result back to the UI in another XML message. Sending and receiving of XML messages between Firefox extension and Java back-end, takes place synchronously over a local Java socket listening on an internal port.

Due to Scramble's dependency on OpenPGP for key management, the Firefox extension communicates with a web of trust (Section~\ref{sec:web_of_trust}) storing all public keys of users who subscribed to the OpenPGP network. Since the OpenPGP network stores more keys than a Scramble user needs, Scramble offers the functionality to store public keys from the OpenPGP network locally in a contact database via the client side Java back-end. In addition, the client-side Java back-end has access to an encrypted list of the user's private keys corresponding to public keys that are already part of the OpenPGP network. With the help of a passphrase the Java back-end has access to these private keys to allow decryption of received messages.

\subsection{Changes to the Existing Environment}
The altered Scramble architecture is schematically illustrated in Figure~\ref{fig:new_scramble_arch}. Scramble still offers the original OpenPGP functionality as an alternative to our IBE implementation. However, for reasons of conciseness Figure~\ref{fig:new_scramble_arch} omits the original implementation although it coexists with our IBE functionality.


\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.72} {
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray!40},
            ]
            
            % Client side polygon
            \draw[dashed] (-5.5,4) -- (-0.4,4) -- (-0.4,-7) -- (-5.5,-7) -- (-5.5,4);
            % OSNs Polygon
            \draw[dashed] (0.5,4) -- (5.5,4) -- (5.5,1.4) -- (0.5,1.4) -- (0.5,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-11.5,4) -- (-6.5,4) -- (-6.5,-7) -- (-11.5,-7) -- (-11.5,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1.5,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (2.25,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3.75,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (3,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4.5,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                %(-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-9,2.5) node [block2] (dkgfront) {PKG Website (PHP Front-end)}
                (-9,-2.5) node [block2] (dkgback) {PKG C++ MIRACL Based Back-end}
                (-9,0) node [block2] (dkgcfront) {PKG Socket (C++ Front-end)}

                
                % Text
                (-3,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (3,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-9,4) node [leg,fill=white] (white_block) {\textbf{Server Side PKG}}
                (-9,-5.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-3,-5.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystorcs) {Encrypted Key Storage}
                (-1.65,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-7.75,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-6,3.15) node [leg,font=\small,fill=white] (white_block) {XML \\ Messages over \\ POST Request}
                (-12,0.5) node [leg,font=\small,fill=white] (white_block) {XML Messages \\ to Other PKGs}
                
                (-3,2.5) node [block2] (ffext) {Scramble Firefox Extension}
                (-3,0) node [block2] (cssocket) {Local C++ Socket}
                (-3,-2.5) node [block2] (csback) {Client Side C++ MIRACL Based Back-end}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (cssocket.north);
        \path (cssocket.south) -- (csback.north);
        %\path (csback.south) -- (db.north);
        \path (ffext.west) -- (dkgfront.east);
        \path (ffext.east) -- (0.5,2.5);
        \path (dkgcfront.north) -- (dkgfront.south);
        \path (csback.south) -- (keystorcs.north);
        \path (dkgback.north) -- (dkgcfront.south);
        \path (keystor.north) -- (dkgback.south);
        \path (dkgcfront.west) -- (-13.5,0);
       \end{scope}

        \end{tikzpicture}
        }
    }

    \caption{New Scramble Architecture}
    \label{fig:new_scramble_arch}
\end{figure}


The new client side Scramble architecture implements a C++ based back-end instead of the earlier Java back-end because the most efficient pairing-based multi precision libraries are written in C. In fact only two pairing-based libraries are widely accepted in practical implementations: MIRACL~\cite{art:Scott03} and PBC~\cite{thesis:Lynn07}. MIRACL was preferred over PBC since it is generally faster in its pairing computations. All core algorithms of MIRACL are implemented in C while a C++ wrapper allows object-oriented programming.

The contact database is removed from the original Scramble implementation as illustrated in Figure~\ref{fig:original_scramble_arch} since public keys no longer have to be explicitly stored in the architecture. More specifically, since Scramble can rely on IBE, the public keys are inherently part of the supported OSN. Therefore, the Firefox extension falls back on a number of calls to supported OSN APIs in order to get all public keys of one's connections.

Figure~\ref{fig:new_scramble_arch} exchanges the web of trust from Figure~\ref{fig:original_scramble_arch} for a DKG infrastructure in order to support IBE without key escrow. For clarity, only one PKG is shown since all PKGs will have the same structure. The PKG supports two front-ends: a C++ based front-end and a PHP based front-end. 

The C++ based front-end of the PKG only serves as a front-end during execution of the DKG protocol. Negotiation of the shares is implemented over synchronous sockets. At the startup of the PKG socket, the administrator is asked for a secret passphrase. Then, the sockets start listening on a predetermined port until all shares are correctly negotiated. Once all PKGs have exchanged their shares, the PKG calculates its public parameters and finishes the \texttt{Setup} step from Algorithm~\ref{alg:our_scheme}. The coefficients of the secret polynomial are encrypted with the earlier specified passphrase along with the negotiated secret share. After storage of these secret parameters, the C++ socket starts listening on another port to handle requests from the PHP front-end. Handling of private key extraction requests is multithreaded to handle requests of multiple clients at the same time.

The PHP based front-end receives private key extraction queries from the Scramble Firefox extension in the form of POST requests. The PKG communicates the requested $\id{}$ to the listening C++ socket in the form of an XML message. After the required MIRACL based pairing computations, the PKG socket sends the response back to the PHP webpage such that it is published in the form of an XML message over HTTPS~\cite{rfc2818}.

Note that the new architecture from Figure~\ref{fig:new_scramble_arch} can be applied to virtually any OSN that identifies its users with publicly available identifiers. However, Scramble is made more user friendly by implementing OSN specific API calls. Currently, an implementation for Facebook serves as a proof of concept. Further extension to support other OSNs could be subject of future work.


\section{Implementation Details}
\label{sec:implementation_details}
The implementation of Algorithm~\ref{alg:our_scheme} still requires some practical design decisions that are further discussed in this section.

\subsection{Type of Elliptic Curve}
For bilinear pairings, the underlying elliptic curve determines which groups are used for the bilinear pairing ${e: G_1 \times G_2 \rightarrow G_T}$ and thus the security level of the application. The MIRACL library supports 5 different curves and 6 different security levels. However, the Barreto-Lynn-Scott (BLS) curve~\cite{art:BarretoLS02} is preferred since it provides the highest level of security in MIRACL. BLS curves rely on Ate pairings~\cite{art:HessSV06} with an embedding degree of 24. Consequently, BLS curves are considered suitable for a security level of 256 bits.

\subsection{Authenticated Encryption Scheme}
An AES-GCM~\cite{art:McGrewV04} implementation is used for the authenticated encryption scheme in Algorithm~\ref{alg:our_scheme} since it is one of the more efficient authenticated encryption schemes unencumbered by patents. The AES-GCM implementation as provided by MIRACL relies on authentication tags of 128 bits. Apart from a symmetric key of 128, 192 or 256 bits, AES-GCM also requires an Initialisation Vector (IV). The recommended length of the IV is 96 bits because it can be handled more efficiently~\cite{rfc5084}.

\subsection{Key Lengths}
Since the maximum level of security in MIRACL is determined by the BLS curve, all implemented key lengths in Algorithm~\ref{alg:our_scheme} follow from the 256 bits security level ($l=256$). Note that in Step 1 of \texttt{Retrieve} the decryption of a recipient's session key is calculated as: 

\begin{equation*}
 w_i \oplus H_2 \left( e \left( sk_{\id{i}}, U \right) \right) = \rho
\end{equation*}
followed by
\begin{equation*}
 v \oplus H_3 \{ \rho \} = k
\end{equation*}
with
\begin{equation*}
 H_2: G_T \rightarrow \{ 0,1 \}^{l}
\end{equation*}
Since $l=256$, $w_i$ and $\rho$ are binary sequences of 256 bits. Hence, $\rho$ only contains sufficient randomness to securely encrypt a session key $k$ of the same length. The full 256 bit $k$ is not completely used for symmetric encryption as the AES-GCM scheme still requires an IV as well. Since the randomness and key freshness of the IV is at least as important as the secrecy of $k$~\cite{nist:dworkin}, it was deliberately chosen not to apply key derivation functions to construct a separate symmetric encryption key and IV from the same value $k$. Therefore, the first 128 bits of $k$ are used as the symmetric key of AES-GCM, while the second 96 bits function as an IV. According to NIST, such practice should ensure confidentiality at least until 2030. However, if a higher level of security should be required, key derivation on $k$ could be considered.

\subsection{Hash Functions}
The hash function $H_1: \{ 0,1 \}^{*} \rightarrow G_1$ is implemented using the MIRACL function call \texttt{hash\textunderscore to\textunderscore group}. Hash function $H_2: G_T \rightarrow \{ 0,1 \}^{256}$ relies on the {MIRACL} \texttt{hash\textunderscore to\textunderscore aes\textunderscore key} function. Both $H_1$ and $H_2$ internally fall back on SHA-256~\cite{nist:fips1804}. The MIRACL provided SHA-256 algorithm is used for implementation of the hash $H_3: \{ 0, 1 \}^{256} \rightarrow \{ 0,1 \}^{256}$ as well.

\subsection{Generating Random Numbers}
Random numbers are generated based on the MIRACL build-in strong random number generator. The provided strong random generator is initialised with a time-of-day value and a binary array of 1024 bits read from \texttt{/dev/urandom}. These values are then used as a seed for the generation of random numbers. The practical implementation of the MIRACL strong random generator is based on an advice published by RSA Laboratories in~\cite{art:Matthews96}.

\subsection{Public Key}
The decision on which string to use as a public IBE key \id{} is dependent on the underlying OSN. The desired properties for \id{} are the following:
\begin{enumerate}
 \item The public key should uniquely identify the user
 \item The public key should be mandatory for every user of the social network
 \item The public key should not change frequently over time
 \item The public key should be an inherent part of the infrastructure of the social network. That is, the previous three properties are already ensured by the provider of the social network.
 \item The public key should be publicly available, even to users that are not part of the set of entities with access to the user's profile $\mathcal{V}_{\id{}}$
\end{enumerate}
In Facebook the best key satisfying these properties is a Facebook username. A Facebook username is ensured to be unique since it is part of a profile's URL, e.g. \url{http://www.facebook.com/profile.name} where \texttt{profile.name} functions as \id{}. Moreover, the Facebook policy ensures this username is mandatory for every user and can only be changed once. Lastly, the Facebook username is also public to outsiders using the Facebook API thereby fulfilling all the required conditions for an IBE key in our architecture.

\section{Implemented Code}
\label{sec:implemented_code}
The complete implementation of our solution can be found at \url{{https://bit.ly/ibeforosns}}. The code is originally developed on OS X 10.9 and compiled with GNU g++ 4.7. Portability to other platforms is currently not supported. 

This section briefly overviews the structure of our code and the encountered issues during implementation.


\subsection{Server Side Implementation}
All software code on the server side implements the \texttt{Setup} and \texttt{KeyGen} steps from Algorithm~\ref{alg:our_scheme}.

\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.7} {
        \begin{tikzpicture}
        
        % PKG
        \begin{class}[text width =8 cm]{PKG}{2,2}
          \attribute{\texttt{- lastReceivedShareGenerator : int}}
          \attribute{\texttt{- myShares : share\textunderscore t *}}
          \attribute{\texttt{- nbOfShares : int}}
          \attribute{\texttt{- P : G2}}
          \attribute{\texttt{- pfc : PFC * }}
          \attribute{\texttt{- poly : Big *}}
          \attribute{\texttt{- portNb : int}}
          \attribute{\texttt{- secret : Big}}
          \attribute{\texttt{- receivedShares : share\textunderscore t *}}
          \attribute{\texttt{- secret : Big }}
          \attribute{\texttt{- serverId : int }}
          \attribute{\texttt{- sj : Big}}
          \attribute{\texttt{- sjP : G2}}
          \attribute{\texttt{- ServerState : state}}
          \operation{\texttt{+ PKG(int serverId, int portNb, int nbOfShares, int threshold, Big order, PFC *pfc, G2 P, Big s)}}
          \operation{\texttt{+ PKG(int serverId, int portNb, int nbOfShares, int threshold, Big order, PFC *pfc, Big s)}}
          \operation{\texttt{+ G1 extract(char * id)}}
          \operation{\texttt{+ int getLastReceivedShareGenerator()}}
          \operation{\texttt{+ G2 getP()}}
          \operation{\texttt{+ int getServerId()}}
          \operation{\texttt{+ share\textunderscore t getShareOf(int serverId)}}
          \operation{\texttt{+ G2 getSjP()}}
          \operation{\texttt{+ ServerState getState()}}
          \operation{\texttt{+ string printState()}}
          \operation{\texttt{+ void setP(G2 P)}}
          \operation{\texttt{+ void setShare(share\textunderscore t share)}}
          \operation{\texttt{+ void getSharesFrom(vector \textless PKG\textgreater serverList)}}
        \end{class}
        
        % share_t
        \begin{class}[text width =9.5 cm]{share t}{ -9 , -9}
          \attribute{\texttt{+ x : int}}
          \attribute{\texttt{+ y : Big}}
          \attribute{\texttt{+ shareGenerator : int }}
        \end{class}
        
        %DKGMessage
        \begin{class}[text width =9.5 cm]{DKGMessage}{-9 , 2}
          \attribute{\texttt{- P : G2}}
          \attribute{\texttt{- int : receiver}}
          \attribute{\texttt{- int : sender}}
          \attribute{\texttt{- share\textunderscore t : share}}
          \attribute{\texttt{- DKGMessageType : type}}
          
          \operation{\texttt{+ DKGMessageType(int sender, int receiver, G2 P)}}
          \operation{\texttt{+ DKGMessageType(int sender, int receiver, share\textunderscore t share)}}
          \operation{\texttt{+ DKGMessage(string xmlString)}}
          \operation{\texttt{+ G2 getP()}}
          \operation{\texttt{+ string printType()}}
          \operation{\texttt{+ int getReceiver()}}
          \operation{\texttt{+ int getSender()}}
          \operation{\texttt{+ share\textunderscore t getShare()}}
          \operation{\texttt{+ DKGMessageType getType()}}
          \operation{\texttt{+ string toString()}}
          \operation{\texttt{- init(int sender, int receiver, DKGMessageType)}}
        \end{class}
        \end{tikzpicture}
        \begin{tikzpicture}[remember picture, overlay]                        
            \node [xshift=-14.85cm, yshift=4.55cm,font=\tiny] (27) {\textbf{\_}};
        \end{tikzpicture}

    }}
    \caption{Class Diagram of Server Side C++ MIRACL Based Back-end}
    \label{fig:class_server_side}
\end{figure}

\subsubsection{Code Structure}
All C++ functions implemented by the server side C++ MIRACL based back-end are illustrated in Figure~\ref{fig:class_server_side}. The following classes are defined:
\begin{description}
 \item[PKG] is a class providing all functionality to compute the shares from the DKG protocol and to keep track of the current state of the PKG server.
 \item[DKGMessage] represents a message PKGs use to negotiate in the DKG protocol. A DKGMessage has either DKGMessageType \texttt{P\textunderscore MESSAGE} or \texttt{SHARE\textunderscore MESSAGE}. 
 \item[share\textunderscore t] is the definition of a structure containing: the serverId owning the share $j = \mathtt{x}$, the share value $\sigma_{jv} = \mathtt{y}$ and the server who generated the share $v = \mathtt{shareGenerator}$ where $j,v$ and $\sigma_{jv}$ refer to the mathematical symbols used in Algorithm~\ref{alg:our_scheme}.
\end{description}

The server side implementation also provides a procedural PKG socket denoted ''C++ Front-end'' in Figure~\ref{fig:new_scramble_arch}. The server code achieves \texttt{Setup} and \texttt{KeyGen} in the following way:

\paragraph{Setup} Every PKG socket initialises the DKG protocol by calling the constructor \texttt{PKG(int serverId, int portNb, int nbOfShares, int threshold, Big order, PFC *pfc, Big s)} where \texttt{serverId} corresponds to the unique PKG identifier, \texttt{nbOfShares} corresponds to the total number of PKG servers $n$, \texttt{threshold} is the threshold number of servers $t$ that can construct the shared secret $sk_{msk}$, \texttt{order} is the order $q$ of the gap groups $G_1$ and $G_2$, \texttt{*pfc} is a pointer to a MIRACL pairing-friendly curve object and \texttt{s} corresponds to the uniformly random generated secret $sk_i$ from the Pedersen DKG protocol in Algorithm~\ref{alg:pedersen_dkg}. Only the PKG socket with \texttt{serverId = 1} is initialised with the constructor \texttt{PKG(int serverId, int portNb, int nbOfShares, int threshold, Big order, PFC *pfc, G2 P, Big s)} which requires an additional \texttt{P} value. After initialisation all sockets wait for the PKG with \texttt{serverId = 1} to send a DKGMessage of type \texttt{P\textunderscore MESSAGE} containing the public \texttt{P} value. Once all PKGs have setup their secret polynomial along with the received \texttt{P} value, all PKGs start distributing their shares in ascending order of their \texttt{serverId} values. These DKGMessages are of type \texttt{SHARE\textunderscore MESSAGE} and contain a share in the form of a share\textunderscore t structure.

The \texttt{toString()} function of a DKGMessage object allows to serialise a DKGMessage to an XML message that can be sent over the C++ socket infrastructure. At receipt of an XML message the PKG socket calls \texttt{DKGMessage(string xmlString)} to reconstruct the original DKGMessage object.

\paragraph{KeyGen} Once all PKGs have verified their shares, the C++ socket starts listening on another port that communicates with the PKG website as illustrated in Figure~\ref{fig:new_scramble_arch}. The Scramble plugin can then publish a POST request to the PKG website in order to receive its secret key. The PKG website forwards this request to the C++ socket in the form of an XML message. The socket replies to this request by executing \texttt{extract(char * id)} and returning an XML message containing the resulting serialised \texttt{G1} object.


\subsubsection{Encountered Issues}

\paragraph{Multithreading} To ensure the PKG implementation can resist intensive traffic, the \texttt{extract(char * id)} function is multithreaded. However, multithreading {{MIRACL}} requires the complete library to be recompiled. Furthermore, every algorithm relying on elliptic curves should start with the initialisation of a MIRACL PFC object which allocates the required memory resources on the heap. After destruction of this PFC object, no further MIRACL calls can be made. Therefore, every PKG object is initialised with a pointer to a PFC object that is never freed at run-time.

\paragraph{DKG in the distributed setting} The first attempt to construct a DKG protocol was made by altering the implementation from Kate and Goldberg~\cite{art:KateHG12}. However, it took us several days to compile the original code on OS X. Furthermore, all obtained executable files were corrupted by segmentation faults. After one intensive week of trial and error still no satisfying results were obtained. Consequently, it was decided to implement our own DKG protocol to show at least the viability of our solution.

\paragraph{Deserialising MIRACL objects} MIRACL objects can be transformed to printable strings. However, despite the popularity of MIRACL, originally no functionality for the conversion of strings back to MIRACL objects was provided. Therefore, we introduced additional functions in the MIRACL library that support deserialising objects for use in network communication.

\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.67} {
        \begin{tikzpicture}
        
        % BroadcastMessage
        \begin{abstractclass}[text width =8 cm]{BroadcastMessage}{2,2}
          \attribute{\texttt{\# message : string }}
          \attribute{\texttt{\# autData : AuthenticatedData *}}
          \attribute{\texttt{\# sessionKey : char[HASH\textunderscore LEN]}}
          \operation{\texttt{\# void getIV(char (\& iv)[HASH\textunderscore LEN/2])}}
          \operation{\texttt{\# void getK(char (\& iv)[HASH\textunderscore LEN/2])}}
          \operation{\texttt{\# Big getSessionKey()}}
          \operation{\texttt{+ AuthenticatedData getAuthenticatedData()}}
          \operation[0]{\texttt{+ string getMessage()}}
        \end{abstractclass}
        
        % PlaintextMessage
        \begin{class}[text width =9 cm]{PlaintextMessage}{ -9 , -6}
          \inherit{BroadcastMessage}
          \attribute{\texttt{- r : Big}}
          \attribute{\texttt{- recipients : vector\textless  string\textgreater}}
          \attribute{\texttt{- recipientHashes : vector\textless G1\textgreater }}
          \attribute{\texttt{- rho : Big}}
          \operation{\texttt{+ PlaintextMessage(string message)}}
          \operation{\texttt{+ void addRecipient(string recipient, PFC *pfc)}}
          \operation{\texttt{+ EncryptedMessage encrypt(const G2\& P, const G2\& Ppub, PFC *pfc)}}
          \operation{\texttt{+ string getMessage()}}
          \operation{\texttt{+ vector <string> getRecipients()}}
          \operation{\texttt{- generateKeys(PFC *pfc)}}
        \end{class}
        
        % EncryptedMessage
        \begin{class}[text width =9 cm]{EncryptedMessage}{2 , -6}
          \inherit{BroadcastMessage}
          \attribute{\texttt{- C : char *}}
          \attribute{\texttt{- Clen : int}}
          \attribute{\texttt{- T : char[TAG\textunderscore LEN]}}
          \operation{\texttt{+ EncryptedMessage(char * A, int Alen, char (\& T)[TAG\textunderscore LEN], char * C, int Clen)}}
          \operation{\texttt{+ EncryptedMessage(string encryptedMessage)}}
          \operation{\texttt{+ PlaintextMessage decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id)}}
          \operation{\texttt{+ string getMessage()}}
        \end{class}
        
        %AuthenticatedData
        \begin{class}[text width =8 cm]{AuthenticatedData}{-9 , 2}
          \attribute{\texttt{- authenticatedData : char *}}
          \attribute{\texttt{- U : G2}}
          \attribute{\texttt{- v : Big}}
          \attribute{\texttt{- ws : vector<Big>}}
          
          \operation{\texttt{+ AuthenticatedData(char * A)}}
          \operation{\texttt{+ void add(Big encryptedRecipientKey)}}
          \operation{\texttt{+ void encodeTo(char * array)}}
          \operation{\texttt{+ vector\textless Big\textgreater getEncryptedRecipientKeys()}}
          \operation{\texttt{+ int getLength()}}
          \operation{\texttt{+ G2 getU()}}
          \operation{\texttt{+ Big getV()}}
          \operation{\texttt{+ void setU(G2 U)}}
          \operation{\texttt{+ void setV(Big v)}}
        \end{class}
        \unidirectionalAssociation {AuthenticatedData}{part of}{1}{BroadcastMessage}
        \end{tikzpicture}
    }}
    \caption{Class Diagram of Client Side C++ MIRACL Based Back-end}
    \label{fig:class_client_side}
\end{figure}
\subsection{Client Side Implementation}
Software code describing the client side implementation achieves the required functionality for the \texttt{Publish} and \texttt{Retrieve} steps from Algorithm~\ref{alg:our_scheme}.

\subsubsection{Code Structure}
All C++ functions implemented by the client side C++ MIRACL based back-end are illustrated in Figure~\ref{fig:class_client_side}. The following classes are defined:
\begin{description}
 \item[AuthenticatedData] describes the data that is authenticated by the AES-GCM implementation. AuthenticatedData corresponds to $\mathcal{A}$ in Algorithm~\ref{alg:our_scheme}.
 \item[BroadcastMessage] is an abstract class that forms the base class of PlaintextMessage and EncryptedMessage. BroadcastMessage contains properties and functions EncryptedMessage and PlaintextMessage have in common.
 \item[PlaintextMessage] corresponds to a BroadcastMessage as it is constructed by the sender before encryption.
 \item[EncryptedMessage] corresponds to a BroadcastMessage as it is sent over the OSN in encrypted form.
\end{description}

The client side implementation also provides a procedural local C++ socket implementation that relies on the classes from the class diagram in Figure~\ref{fig:class_client_side} to communicate with the Firefox extension, as illustrated in Figure~\ref{fig:new_scramble_arch}. The client side code realises \texttt{Publish} and \texttt{Retrieve} as follows:

\paragraph{Publish}
When a user broadcasts a message, he inputs the desired plaintext message in the Firefox extension and selects the \id{}s of the intended recipients. The Firefox extension sends this data to the C++ back-end via the local C++ socket from Figure~\ref{fig:new_scramble_arch}. The C++ socket then initialises a PlaintextMessage object with the help of constructor \texttt{PlaintextMessage(string message)} and adds the recipients with \texttt{addRecipient(string recipient, PFC *pfc)}. After initialisation, the function \texttt{getMessage()} can return the plaintext message $m$ without the concatenated intended recipient set $\mathcal{S}$. The recipients of a PlaintextMessage can be retrieved with the \texttt{getRecipients()} function. A PlaintextMessage object is encrypted by calling \texttt{encrypt(const G2\& P, const G2\& Ppub, PFC *pfc)} where \texttt{P} and \texttt{Ppub} denote the public parameters and \texttt{*pfc} is a pointer to a MIRACL pairing-friendly curve object. The returned result is an EncryptedMessage object.


\paragraph{Retrieve}
When the local C++ socket receives an XML message containing an encrypted broadcast message, an EncryptedMessage object is initialised with the help of the constructor \texttt{EncryptedMessage(string encryptedMessage)}. After object construction, the \texttt{getMessage()} function returns a string of the ciphertext $\mathcal{B}$ from Algorithm~\ref{alg:our_scheme} in base64 encoding~\cite{rfc4648}. An EncryptedMessage object can be decrypted by calling \texttt{decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id)} where \texttt{P} and \texttt{Ppub} denote the public parameters, \texttt{*pfc} is a pointer to a MIRACL pairing-friendly curve object and \texttt{s\textunderscore id} is the user's secret key. The returned result is a PlaintextMessage object.

\subsubsection{Encountered Issues}
The most important improvement during the implementation of the client side software code was precomputing the public parameters. MIRACL provides function calls to precompute points in $G_2$ for multiplication and points in $G_T$ for exponentiation. Since the public parameters do not change during the lifetime of our infrastructure these parameters only need to be precomputed once. The execution times for the \texttt{Retrieve} step in Table~\ref{table:performance_publish_and_retrieve} are three times as fast than without precomputation.

During the implementation process our code slowly evolved from procedural code to the object oriented code in Figure~\ref{fig:class_client_side}. After introduction of the function call \texttt{decrypt(G2 P, G2 Ppub, PFC *pfc, G1 s\textunderscore id)}, we noticed very slow decryption times. The reason for the decrease in decryption time is explained by the handling of function arguments in C++. Normally, C++ creates a new object for every function argument. Consequently, the \texttt{P} and \texttt{Ppub} objects lost their internal state along with their precomputed values. This was resolved by altering the function call to \texttt{decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id)}.

\section{Performance Analysis}
\label{sec:performance_analysis}
All performance experiments were conducted on an Intel Core 2.4 GHz i5 processor with 8 Gb of 1600 MHz DDR3L onboard memory. Execution times arise from the aforementioned implementation details applied to Algorithm~\ref{alg:our_scheme}. The results are illustrated in Table~\ref{table:performance_setup}, Table~\ref{table:performance_keygen} and Table~\ref{table:performance_publish_and_retrieve} and further discussed in this section.

\subsection{Setup}
For every PKG $v$, PKG $j$ needs to compute and communicate an additional share $\sigma_{jv}$. Therefore, the execution time of the \texttt{Setup} stage from Algorithm~\ref{alg:our_scheme} is mainly dependent on the total number of PKGs $n$. Although negligible, the setup stage also contains a dependency on the threshold parameter $t$ since it determines the order of the generated polynomials. However, the execution times listed in Table~\ref{table:performance_setup} mainly consist of communication overhead due to the synchronous sockets. Since our current implementation is only simulated in a local environment by sockets listening on different ports, setup times are expected to increase when translated to a distributed setting.

\begin{table}
  \centering
  \begin{tabular}{@{}rr@{}} \toprule
    Total number of PKGs $n$ & Setup Time (ms) \\ \midrule
    2 & 66.6  \\
    5 & 112.6  \\
    10 & 116.8  \\
    15 & 123.2  \\ 
    50 & 142.3 \\ \bottomrule
  \end{tabular}
  \caption{Performance of the \texttt{Setup} stage in function of the total number of PKGs.}
  \label{table:performance_setup}
\end{table}


\subsection{KeyGen}
The larger the threshold $t$ of the DKG protocol, the more PKGs need to be consulted. For every contacted PKG, two additional pairing computations are required due to the check in step 5 of the \texttt{KeyGen} stage in Algorithm~\ref{alg:our_scheme}. The execution times in Table~\ref{table:performance_keygen} primarily consist of these pairing computations in addition to the communication overhead. Analogous to the execution times of the \texttt{Setup} stage, the contribution by communication overhead is expected to increase in a distributed DKG environment. 

\begin{table}
  \centering
  \begin{tabular}{@{}rr@{}} \toprule
    Threshold number of PKGs $t$ & Setup Time (ms) \\ \midrule
    2 & 1175.4 \\
    5 & 2785.0 \\
    10 & 5781.2 \\
    15 & 8625.8 \\ 
    50 & 29318.4 \\ \bottomrule
  \end{tabular}
  \caption{Performance of the \texttt{KeyGen} stage in function of the threshold number of PKGs.}
  \label{table:performance_keygen}
\end{table}

\subsection{Publish}
Encryption times are linearly dependent on the number of intended recipients since more intensive pairing computations are required for each additional user included in the intended recipient set, as illustrated by Table~\ref{table:performance_publish_and_retrieve}.

\subsection{Retrieve}
Each recipient has to decrypt $w_i$ an average of $\eta/2$ times to retrieve the secret session key $k$. However, the experiments as shown in Table~\ref{table:performance_publish_and_retrieve} measured the worst-case execution time for the \texttt{Retrieve} stage of Algorithm~\ref{alg:our_scheme} since the recipient had to decrypt all $w_i$ values before retrieving $k$ in the last attempt. Only after recovering $k$, the recipient can decrypt the ciphertext using AES-GCM.

In future optimisations of our current implementation, techniques of randomness reuse should be considered. The concept of randomness reuse as originally proposed by Kurosawa~\cite{art:Kurosawa01} introduces a deterministic component to random elements of a BE scheme such that shorter ciphertexts and computationally more efficient schemes can be achieved. However, randomness reuse should be applied with great care as it can significantly reduce the security level of a scheme. Since randomness reuse depends on the underlying BE scheme, an extensive analysis of the scheme should precede implementation of randomness reuse techniques. Therefore, randomness reuse is currently not included in our implementation.

\begin{table}
  \centering
  \begin{tabular}{@{}rrr@{}} \toprule
    \multicolumn{3}{r}{Execution Time (ms)} \\ \cmidrule(r){2-3}
    Number of Recipients & \texttt{Publish} & \texttt{Retrieve} \\ \midrule
    %%%%%%%%%%%%%%%%%%%%%
    % CCA Secure scheme %
    %%%%%%%%%%%%%%%%%%%%%
    1 & 284.5 & 275.4  \\
    % 5 & 1278.750 \ms & 357.302 \ms \\
    10 & 2564.5  & 460.9  \\
    15 & 3799.6  & 560.6  \\
    % 20 & 5029.470 \ms & 657.030 \ms \\
    % 25 & 6258.510 \ms & 761.765 \ms \\
    50 & 12300.5  & 1237.8  \\
    100 & 25867.7  & 2260.2  \\  \bottomrule
    %%%%%%%%%%%%%%%%%%%%%
    % CPA Secure scheme %
    %%%%%%%%%%%%%%%%%%%%%
    % 1 & 270.872 & 249.1 \\
    % 5 & 1270.1 & 258.7 \\
    % 10 & 2498.6 & 259.6 \\
    % 15 & 3847.3 & 266.1 \\
    % 20 & 4975.4 & 266.9 \\
    % 25 & 6135.0 & 265.0 \\
    % 50 & 12701.3 & 284.214 \\
    % 100 & 25540.5 & 377.8 \\
  \end{tabular}
  \caption{Performance of the \texttt{Publish} and \texttt{Retrieve} stages in function of the number of intended recipients.}
  \label{table:performance_publish_and_retrieve}
\end{table}

\section{Current Limitations}
\label{sec:limitations_of_implementation}
The algorithm as it is currently implemented only serves as a proof of concept since it lacks a number of requirements needed for secure use in practice. These aspects were not implemented due to the limited time available. Since all core requirements for the protocol in Algorithm~\ref{alg:our_scheme} are present, only the aspects for practical usage in more hostile environments are missing. However, including these aspects should be straightforward and is only a matter of implementation instead of deliberate design decisions.

\subsection{Client Side}
Since the IBE scheme is integrated in the existing Scramble UI, our current prototype does not require drastic adaptations to the client side implementation. The major drawback of our IBE proposal is that it makes the Scramble plugin more dependent on the underlying OSN. Consequently, every OSN should be separately integrated into the Scramble plugin since each OSN offers its own API calls for reading out friend connections. More OSNs than Facebook should be actively supported by the IBE Scramble tool to motivate wide user adaptation of the plugin. However, the open-source license of Scramble motivates tech-savvy users to extend the current implementation for support of their own favourite OSNs. 

\subsection{Server Side}
In its present form, the PKG is only simulated in a local environment. Therefore, it suffices to rely on synchronous communication over C++ sockets each listening on a different port. However, before adaption to a world-wide DKG network is possible, the protocol should take more asynchronous aspects into account such as connection-loss, DOS-attacks or undelivered packets. Kate et al.~\cite{art:KateHG12} propose a more advanced DKG protocol in the asynchronous setting that could be adapted for our IBE setting.

Since the DKG protocol is currently simulated in a local environment, all PKG sockets communicate their XML messages in plain text. More secure socket protocols should be considered such as SSL~\cite{rfc6101} for adoption to a more hostile distributed setting.

Furthermore, the current assumptions on the PKGs (Section~\ref{sec:updated_model}) are too severe for practical environments. In practice, the current Pedersen DKG scheme~\cite{art:Pedersen91a} is insecure and is better replaced by the one from Gennaro et al.~\cite{art:GennaroJKR07}. If all mentioned updates on the current server side scheme are effectively achieved, more relaxed assumptions on the PKG are in place. With less stringent PKG assumptions, the DKG network could even be partially supported by the OSN providers to improve their privacy-friendly image.

\subsection{Limitations Effecting Both Client and Server}
Currently, private key extraction takes the form of a POST request over HTTPS~\cite{rfc2818}. Although the PKGs publish the response in plain text to their PHP website, the communication is encrypted by a self-signed SSL certificate. Ideally, this certificate is signed by a world-wide trusted CA such that the client-side implementation can effectively verify whether it is communicating with a valid PKG.

Although web communication between the client side Scramble tool and the server side PKG is already encrypted, a client can request the private key parameters for every $\id{}$ since there is no authentication mechanism checking the user's identity. However, Facebook provides third party authentication in its API. If a Facebook login dialogue is integrated in the Scramble UI, the returned Facebook authentication token serves as a proof to the PKG that the requester of the private key resembles the owner of the corresponding Facebook profile.

\section{Summary}
In this chapter we summarised the implementation process of applying Algorithm~\ref{alg:our_scheme} to Facebook in the form of a Firefox extension called Scramble. After an overview of the existing Scramble architecture, adaptations to the existing architecture were proposed to enable implementation of the design from Chapter~4. The multi-precision library MIRACL was used to implement all algebraic computations. In a next section we uncovered how our code was structured and the issues we encountered for both the client and server side of our application. This was followed by a performance evaluation which showed the overhead of our implementation is tolerable for practical usage in OSNs. We concluded the chapter with the limitations of our current proof of concept and proposed how these could resolved straightforwardly.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
