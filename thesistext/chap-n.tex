\chapter{Implementation}
\label{cha:n}
To show the viability of our solution, Algorithm~\ref{alg:our_scheme} is implemented on Facebook, currently the OSN with the largest total number of users on the internet. The user interface of our implementation relies on Scramble, an existing open-source Firefox plugin for broadcast encryption on OSNs.

The structure of this chapter is as follows. The different components in the existing Scramble architecture are highlighted before turning to the required adaptations on the existing architecture to implement our solution (Section~\ref{sec:software_architecture}). Next, a discussion follows on how the practical details of the cryptographic building blocks and parameters from Algorithm~\ref{alg:our_scheme} are implemented (Section~\ref{sec:implementation_details}). Furthermore, the structure of our code along with encountered implementation issues is described (Section~\ref{sec:implemented_code}). This is concluded by a performance analysis (Section~\ref{sec:performance_analysis}) and a list of limitations of our current implementation (Section~\ref{sec:limitations_of_implementation}).
% Wat moet er in dit hoofdstuk staan?
%%%%%% Implementatiedetails van het schema
% Welk sociaal netwerk? 
% Gebruikt Authenticated Encryption scheme
% Keylengths
% Welke elliptische curve?
% Hoe worden random getallen gekozen?

%%%%%% Architectuur van de implementatie
% Kijk naar figuur van de hummingbirdpaper
%%%% Implementatie aan client side
% Structuur van de code
% Encountered issues
%%%% Implementatie DKG
%% Structuur van de code
%% Encountered issues
% MIRACL is niet parallelliseerbaar

%%%%% Future work
% DKGs praten in plain text
% Aanvraag van de secret key gebeurt nu zonder authenticatiemechanisme
%%%%% Opgelet voor
% Javascript leest input uit
% User mag geen recipient set via de OSN specifiÃ«ren
% Gebruikers die reageren op statussen worden wel plots bekend uit de recipient set => mogelijke workaround is om hele conversatie weg van het sociaal netwerk te laten gebeuren => op die manier drijf je steeds verder af van het oorspronkelijk sociaal netwerk
% Receivers die het sociaal contract breken
% Fake profielen kunnen worden aangemaakt door gebruikers

\section{Software Architecture}
\label{sec:software_architecture}
The high level structure of the current Scramble implementation is presented along with the required changes to adapt it for our IBE architecture.

\subsection{Software Environment}
Despite the avoidance of complex third party infrastructures, some software is needed that effectively implements Algorithm~\ref{alg:our_scheme} in a user-friendly way. Ideally, this is an easy-to-install piece of software that runs as an additional layer on top of the current infrastructure of the OSN user. Therefore, it was chosen to implement Algorithm~\ref{alg:our_scheme} in the form of a browser extension.

Since Scramble~\cite{art:BeatoKW11} already has a user friendly interface that supports all required use cases to implement encryption on OSNs, it is natural to integrate our IBE scheme into Scramble. Besides from Scramble being open source and lightweight, the most important trigger to modify the existing Scramble code is that it is developed at KU Leuven~\footnote{The scramble code can be downloaded at \url{https://www.cosic.esat.kuleuven.be/scramble/}}.

\subsection{Existing Environment}
Scramble~\cite{art:BeatoKW11} is a Firefox extension that relies on OpenPGP~\cite{rfc4880} for encryption, access control and key management. Due to the use of OpenPGP, Scramble works independent of the underlying OSN. In fact, Scramble only functions as an encryption and decryption tool that can be used on any website offering users to submit content. However, users who want to be part of the recipient set of the uploaded messages need to upload a public key to the OpenPGP network beforehand. The architecture overview of the Scramble environment is illustrated in Figure~\ref{fig:original_scramble_arch}.

Since Scramble is a Firefox extension, the user interface (UI) is implemented in Javascript. Although Javascript is ideal for synchronous UIs, it is not the desired programming language for computational demanding tasks such as encryption and decryption. Therefore, Scramble communicates with a back-end in Java that implements all cryptographic operations. Every time a user selects a computation intensive task in the Javascript UI, Javascript sends an XML message requesting the result from the client side Java back-end. The Java back-end processes the request and immediately sends the result in another XML message back to the UI. Sending and receiving of XML messages between Firefox extension and Java back-end, takes place synchronously over a socket listening on an internal port.

Scramble relies on OpenPGP for key management. Therefore, the Firefox extension communicates with a web of trust (Section~\ref{sec:web_of_trust}) storing all public keys of users who subscribed to the OpenPGP network. Because the OpenPGP network stores more keys than a Scramble user needs, Scramble offers the functionality to store public keys from the OpenPGP network locally in a contact database via the client side Java back-end. Furthermore, the client-side Java back-end has access to an encrypted list of the user's secret keys corresponding to public keys that are already in the OpenPGP network. With the help of a passphrase the Java back-end has access to these private keys to allow encryption of received messages.


\begin{figure}
    \begin{center}
    \noindent\makebox[\textwidth]{
        \scalebox{0.72}{
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray},
            ]
            
            % Client side polygon
            \draw[dashed] (-9,4) -- (-1,4) -- (-1,-4.25) -- (-9,-4.25) -- (-9,4);
            % OSNs Polygon
            \draw[dashed] (0,4) -- (5,4) -- (5,1.4) -- (0,1.4) -- (0,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-14,4) -- (-10,4) -- (-10,-2) -- (-14,-2) -- (-14,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (1.5,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (2.5,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                (-5,2.5) node [block2] (ffext) {Scramble Firefox Extension}
                (-5,0) node [block2] (csback) {Client Side Java Back-end}
                (-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-7,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-12,2.5) node [block2] (pgp) {OpenPGP}
                (-12,-0.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (pkstor) {Public Key Storage}

                
                % Text
                (-5,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (2.5,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-3.5,1.15) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-8.5,2.8) node [leg,font=\small,fill=white] (white_block) {OpenPGP Keys}
                (-12,4) node [leg,fill=white] (white_block) {\textbf{Web of Trust}}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (csback.north);
        \path (csback.south east) -- (db.north);
        \path (ffext.west) -- (pgp.east);
        \path (ffext.east) -- (0,2.5);
        \path (keystor.north) -- (csback.south west);
        \path (pkstor.north) -- (pgp.south);
       \end{scope}

        \end{tikzpicture}
        }
    }
    \end{center}
    \caption{Original Scramble Architecture}
    \label{fig:original_scramble_arch}
\end{figure}

\subsection{Changes to the Existing Environment}
The altered Scramble architecture is schematically illustrated in Figure~\ref{fig:new_scramble_arch}. Scramble still offers the original functionality as an alternative to our IBE implementation. However, for reasons of conciseness Figure~\ref{fig:new_scramble_arch} omits the original OpenPGP implementation although it is not removed.


\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.72} {
        \begin{tikzpicture}[auto, node distance=-2mm, align=center,
            block/.style={rectangle,text width=6em,text centered,minimum height=9mm},
            line/.style={draw,very thick, ->},
            line2/.style={draw,very thick, <->},
            leg/.style={text centered},
            block2/.style={draw, rectangle,text width=7em,text centered,minimum height=9mm,fill=lightgray},
            ]
            
            % Client side polygon
            \draw[dashed] (-5.5,4) -- (-0.4,4) -- (-0.4,-4.5) -- (-5.5,-4.5) -- (-5.5,4);
            % OSNs Polygon
            \draw[dashed] (0.5,4) -- (5.5,4) -- (5.5,1.4) -- (0.5,1.4) -- (0.5,4);
            % OpenPGP Polygon
            %\draw[dashed] (0.5,0.7) -- (5.7,0.7) -- (5.7,-1.2) -- (0.5,-1.2) -- (0.5,0.7);
            \draw[dashed] (-11.5,4) -- (-6.5,4) -- (-6.5,-7) -- (-11.5,-7) -- (-11.5,4);
            % Server side polygon
             
            %\draw[help lines] (-16,-5) grid (6,4);
            \path
                % Images
                (1.5,3.25) node [block] (fb) {\includegraphics[scale=0.07]{img/fb.png}}
                (2.25,2.1) node [block] (gplus) {\includegraphics[scale=0.07]{img/gplus.png}}
                (3.75,2.1) node [block] (linkedin) {\includegraphics[scale=0.1]{img/linkedin.png}}
                (3,3.25) node [block] (twitter) {\includegraphics[scale=0.05]{img/twitter.png}}
                (4.5,3.25) node [block] (tumblir) {\includegraphics[scale=0.1]{img/tumblr.png}}

                % Text boxes
                %(-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (db) {Contact Database}
                (-9,2.5) node [block2] (dkgfront) {PKG Website (PHP Front-end)}
                (-9,-2.5) node [block2] (dkgback) {PKG C++ MIRACL Based Back-end}
                (-9,0) node [block2] (dkgcfront) {PKG Socket (C++ Front-end)}

                
                % Text
                (-3,4) node [leg,fill=white] (white_block) {\textbf{Client Side Scramble}}
                (3,4) node [leg,fill=white] (white_block) {\textbf{OSNs}}
                (-9,4) node [leg,fill=white] (white_block) {\textbf{Server Side PKG}}
                (-9,-5.5) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystor) {Encrypted Key Storage}
                (-3,-3) node [draw,cylinder,shape border rotate=90,text width=6em,aspect=0.25] (keystorcs) {Encrypted Key Storage}
                (-1.65,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-7.75,1.25) node [leg,font=\small] (white_block) {XML Messages \\ over Socket}
                (-6,3.15) node [leg,font=\small,fill=white] (white_block) {XML \\ Messages over \\ POST Request}
                (-12,0.5) node [leg,font=\small,fill=white] (white_block) {XML Messages \\ to Other PKGs}
                
                (-3,2.5) node [block2] (ffext) {Scramble Firefox Extension}
                (-3,0) node [block2] (csback) {Client Side C++ MIRACL Based Back-end}
                ;
                
       %\node[node distance=2mm, above=of pkg] {\textbf{OSN Broadcast Server}};
       
       \begin{scope}[every path/.style=line]
        %\path (alice.east) -- (pkg.west);
        %\path (pkg.south west) -- (adv.north);
       \end{scope}
       \begin{scope}[every path/.style=line2]
        \path (ffext.south) -- (csback.north);
        %\path (csback.south) -- (db.north);
        \path (ffext.west) -- (dkgfront.east);
        \path (ffext.east) -- (0.5,2.5);
        \path (dkgcfront.north) -- (dkgfront.south);
        \path (csback.south) -- (keystorcs.north);
        \path (dkgback.north) -- (dkgcfront.south);
        \path (keystor.north) -- (dkgback.south);
        \path (dkgcfront.west) -- (-13.5,0);
       \end{scope}

        \end{tikzpicture}
        }
    }

    \caption{New Scramble Architecture}
    \label{fig:new_scramble_arch}
\end{figure}


The new client side Scramble architecture implements a C++ based back-end instead of the earlier Java back-end because the most efficient pairing-based multi precision libraries are written in C. In fact only two pairing-based libraries are widely accepted in practical implementations: MIRACL~\cite{art:Scott03} and PBC~\cite{thesis:Lynn07}. MIRACL was preferred over PBC since it is generally faster in its pairing computations. All core algorithms of MIRACL are implemented in C while a C++ wrapper allows object-oriented programming.

The contact database is removed from the original Scramble implementation as illustrated in Figure~\ref{fig:original_scramble_arch} since public keys no longer have to be explicitly stored in the architecture. More specifically, since Scramble can rely on IBE, the public keys are inherently part of the supported OSN. Therefore, the Firefox extension falls back on a number of calls to supported OSN APIs in order to get all public keys of one's connections.

Figure~\ref{fig:new_scramble_arch} exchanges the web of trust from Figure~\ref{fig:original_scramble_arch} for a DKG infrastructure in order to support IBE without key escrow. For clarity, only one PKG is shown since all PKGs will have the same structure. The PKG supports two front-ends: a C++ based front-end and a PHP based front-end. 

The C++ based front-end of the PKG only serves as a front-end during execution of the DKG protocol. Negotiation of the shares is implemented over synchronous sockets. At the startup of the PKG socket, the administrator is asked for a secret passphrase. Then, the sockets start listening on a predetermined port until all shares are correctly negotiated. Once all PKGs have exchanged their shares, the PKG calculates its public parameters and finishes the \texttt{Setup} step from Algorithm~\ref{alg:our_scheme}. The coefficients of the secret polynomial are encrypted with the earlier specified passphrase along with the negotiated secret share. After storage of these secret parameters, the C++ socket starts listening on another port to handle requests from the PHP front-end. Handling of private key extraction requests is multithreaded to handle requests of multiple clients at the same time.

The PHP based front-end receives private key extraction queries from the Scramble Firefox extension in the form of POST requests. The PKG communicates the requested $\id{}$ to the listening C++ socket in the form of an XML message. After the required MIRACL based pairing computations, the PKG socket sends the response back to the PHP webpage such that it is published in the form of an XML message over HTTPS~\cite{rfc2818}.

Note that the new architecture from Figure~\ref{fig:new_scramble_arch} can be applied to virtually any OSN that identifies its users with publicly available identifiers. However, Scramble is made more user friendly by implementing OSN specific API calls. Currently, an implementation for Facebook serves as a proof-of-concept. Further extension to support other OSNs could be subject of future work.


\section{Implementation Details}
\label{sec:implementation_details}
The implementation of Algorithm~\ref{alg:our_scheme} still requires some practical design decisions that are further discussed in this section.

\subsection{Type of Elliptic Curve}
For bilinear pairings, the underlying elliptic curve determines which groups are used forthe bilinear pairing ${e: G_1 \times G_2 \rightarrow G_T}$ and thus the security level of the application. The MIRACL library supports 5 different curves and 6 different security levels. However, the Barreto-Lynn-Scott (BLS) curve~\cite{art:BarretoLS02} is preferred since it provides the highest level of security in MIRACL. BLS curves rely on Ate pairings~\cite{art:HessSV06} with an embedding degree of 24. Consequently, BLS curves are considered suitable for a security level of 256 bits.

\subsection{Authenticated Encryption Scheme}
An AES-GCM~\cite{art:McGrewV04} implementation is used for the authenticated encryption scheme in Algorithm~\ref{alg:our_scheme} since it is one of the more efficient authenticated encryption schemes unencumbered by patents. The AES-GCM implementation as provided by MIRACL is used with authentication tags of 128 bits. Apart from a symmetric key of 128, 192 or 256 bits, AES-GCM also requires an Initialisation Vector (IV). The recommended length of the IV is 96 bits because it can be handled more efficiently~\cite{rfc5084}.

\subsection{Key Lengths}
Since the maximum level of security in MIRACL is determined by the BLS curve, all implemented key lengths in Algorithm~\ref{alg:our_scheme} follow from the 256 bits security level ($l=256$). Note that in Step 1 of \texttt{Retrieve} the decryption of a recipient's session key is calculated as: 

\begin{equation*}
 w_i \oplus H_2 \left( e \left( sk_{\id{i}}, U \right) \right) = \rho
\end{equation*}
followed by
\begin{equation*}
 v \oplus H_3 \{ \rho \} = k
\end{equation*}
with
\begin{equation*}
 H_2: G_T \rightarrow \{ 0,1 \}^{l}
\end{equation*}
Since $l=256$, $w_i$ and $\rho$ are binary sequences of 256 bits. Hence, $\rho$ only contains sufficient randomness to securely encrypt a session key $k$ of the same length. The full 256 bit $k$ is not completely used for symmetric encryption as the AES-GCM scheme still requires an IV as well. Since the randomness and key freshness of the IV is at least as important as the secrecy of $k$~\cite{nist:dworkin}, it was deliberately chosen not to apply key derivation functions to derive a separate symmetric encryption key and IV from the same value $k$. Therefore, the first 128 bits of $k$ are used as the symmetric key of AES-GCM, while the second 96 bits function as an IV. According to NIST, this should ensure confidentiality at least until 2030. However, if a higher level of security should be required, key derivation on $k$ could be considered.

\subsection{Hash Functions}
The hash function $H_1: \{ 0,1 \}^{*} \rightarrow G_1$ is implemented using the MIRACL function call \texttt{hash\textunderscore to\textunderscore group}. Hash function $H_2: G_T \rightarrow \{ 0,1 \}^{256}$ relies on the MIRACL\texttt{hash\textunderscore to\textunderscore aes\textunderscore key} function. Both $H_1$ and $H_2$ internally fall back on SHA-256~\cite{nist:fips1804}. The MIRACL provided SHA-256 algorithm is also used for implementation of the hash $H_3: \{ 0, 1 \}^{256} \rightarrow \{ 0,1 \}^{256}$.

\subsection{Generating Random Numbers}
Random numbers are generated using the MIRACL build-in strong random number generator. The strong random generator is initialised with a time-of-day value and a binary array of 1024 bits read from \texttt{/dev/urandom}. These values are then used as a seed for the generation of random numbers. The practical implementation of the MIRACL strong random generator is based on an advice published by RSA Laboratories in~\cite{art:Matthews96}.

\subsection{Public Key}
The decision on which string to use as a public IBE key \id{} is dependent on the underlying OSN. The desired properties for \id{} are the following:
\begin{enumerate}
 \item The public key should uniquely identify the user
 \item The public key should be mandatory for every user of the social network
 \item The public key should not change frequently over time
 \item The public key should be an inherent part of the infrastructure of the social network thereby meaning that the previous three properties are already ensured by the provider of the social network.
 \item The public key should be publicly available, even to users that are not part of the set of entities with access to the user's profile $\mathcal{V}_{\id{}}$
\end{enumerate}
In Facebook the best key satisfying these properties is a Facebook username. A Facebook username is ensured to be unique since it is part of a profile's URL, e.g. \url{http://www.facebook.com/profile.name} where \texttt{profile.name} functions as \id{}. Moreover, the Facebook policy ensures that this username is mandatory for every user and can only be changed once. Lastly, the Facebook username is also public to outsiders using the Facebook API thereby fulfilling all the required conditions for an IBE key in our architecture.

\section{Implemented Code}
\label{sec:implemented_code}
\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.7} {
        \begin{tikzpicture}
        
        % BroadcastMessage
        \begin{abstractclass}[text width =8 cm]{BroadcastMessage}{2,2}
          \attribute{\# message : string }
          \attribute{\# autData : AuthenticatedData *}
          \attribute{\# sessionKey : char[HASH\textunderscore LEN]}
          \operation{\# void getIV(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{\# void getK(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{\# Big getSessionKey()}
          \operation{+ AuthenticatedData getAuthenticatedData()}
          \operation[0]{+ string getMessage()}
        \end{abstractclass}
        
        % PlaintextMessage
        \begin{class}[text width =9 cm]{PlaintextMessage}{ -9 , -6}
          \inherit{BroadcastMessage}
          \attribute{- r : Big}
          \attribute{- recipients : vector\textless  string\textgreater}
          \attribute{- recipientHashes : vector\textless G1\textgreater }
          \attribute{- rho : Big}
          \operation{+ PlaintextMessage(string message)}
          \operation{+ void addRecipient(string recipient, PFC *pfc)}
          \operation{+ EncryptedMessage encrypt(const G2\& P, const G2\& Ppub, PFC *pfc)}
          \operation{+ string getMessage()}
          \operation{+ vector <string> getRecipients()}
          \operation{- generateKeys(PFC *pfc)}
        \end{class}
        
        % EncryptedMessage
        \begin{class}[text width =9 cm]{EncryptedMessage}{2 , -6}
          \inherit{BroadcastMessage}
          \attribute{- C : char *}
          \attribute{- Clen : int}
          \attribute{- T : char[TAG\textunderscore LEN]}
          \operation{+ EncryptedMessage(char * A, int Alen, char (\& T)[TAG\textunderscore LEN], char * C, int Clen)}
          \operation{+ EncryptedMessage(string encryptedMessage)}
          \operation{+ PlaintextMessage decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id, PFC *pfc )}
          \operation{+ string getMessage()}
        \end{class}
        
        %AuthenticatedData
        \begin{class}[text width =8 cm]{AuthenticatedData}{-9 , 2}
          \attribute{- authenticatedData : char *}
          \attribute{- U : G2}
          \attribute{- v : Big}
          \attribute{- ws : vector<Big>}
          
          \operation{+ AuthenticatedData(char * A)}
          \operation{+ void add(Big encryptedRecipientKey)}
          \operation{+ void encodeTo(char * array)}
          \operation{+ vector\textless Big\textgreater getEncryptedRecipientKeys()}
          \operation{+ int getLength()}
          \operation{+ G2 getU()}
          \operation{+ Big getV()}
          \operation{+ void setU(G2 U)}
          \operation{+ void setV(Big v)}
        \end{class}
        \unidirectionalAssociation {AuthenticatedData}{part of}{1}{BroadcastMessage}
        \end{tikzpicture}
    }}
    \caption{Class Diagram of Client Side C++ MIRACL Based Back-end}
    \label{fig:class_client_side}
\end{figure}
\subsection{Client-Side Implementation}
\subsubsection{Code Structure}
\textcolor{red}{TODO: give a short description on what each function implements}

\subsubsection{Encountered Issues}
\textcolor{red}{TODO: Say something about pre-computation in MIRACL and why the const G2\& is necessary.}

\subsection{Server-Side Implementation}

\begin{figure}
    \centering
    \noindent\makebox[\textwidth]{
        \scalebox{0.7} {
        \begin{tikzpicture}
        
        % BroadcastMessage
        \begin{abstractclass}[text width =8 cm]{BroadcastMessage}{2,2}
          \attribute{\# message : string }
          \attribute{\# autData : AuthenticatedData *}
          \attribute{\# sessionKey : char[HASH\textunderscore LEN]}
          \operation{\# void getIV(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{\# void getK(char (\& iv)[HASH\textunderscore LEN/2])}
          \operation{\# Big getSessionKey()}
          \operation{+ AuthenticatedData getAuthenticatedData()}
          \operation[0]{+ string getMessage()}
        \end{abstractclass}
        
        % PlaintextMessage
        \begin{class}[text width =9 cm]{PlaintextMessage}{ -9 , -6}
          \inherit{BroadcastMessage}
          \attribute{- r : Big}
          \attribute{- recipients : vector\textless  string\textgreater}
          \attribute{- recipientHashes : vector\textless G1\textgreater }
          \attribute{- rho : Big}
          \operation{+ PlaintextMessage(string message)}
          \operation{+ void addRecipient(string recipient, PFC *pfc)}
          \operation{+ EncryptedMessage encrypt(const G2\& P, const G2\& Ppub, PFC *pfc)}
          \operation{+ string getMessage()}
          \operation{+ vector <string> getRecipients()}
          \operation{- generateKeys(PFC *pfc)}
        \end{class}
        
        % EncryptedMessage
        \begin{class}[text width =9 cm]{EncryptedMessage}{2 , -6}
          \inherit{BroadcastMessage}
          \attribute{- C : char *}
          \attribute{- Clen : int}
          \attribute{- T : char[TAG\textunderscore LEN]}
          \operation{+ EncryptedMessage(char * A, int Alen, char (\& T)[TAG\textunderscore LEN], char * C, int Clen)}
          \operation{+ EncryptedMessage(string encryptedMessage)}
          \operation{+ PlaintextMessage decrypt(const G2\& P, const G2\& Ppub, PFC *pfc, const G1\& s\textunderscore id, PFC *pfc )}
          \operation{+ string getMessage()}
        \end{class}
        
        %DKGMessage
        \begin{class}[text width =8 cm]{DKGMessage}{-9 , 2}
          \attribute{- authenticatedData : char *}
          \attribute{- U : G2}
          \attribute{- v : Big}
          \attribute{- ws : vector<Big>}
          
          \operation{+ AuthenticatedData(char * A)}
          \operation{+ void add(Big encryptedRecipientKey)}
          \operation{+ void encodeTo(char * array)}
          \operation{+ vector\textless Big\textgreater getEncryptedRecipientKeys()}
          \operation{+ int getLength()}
          \operation{+ G2 getU()}
          \operation{+ Big getV()}
          \operation{+ void setU(G2 U)}
          \operation{+ void setV(Big v)}
        \end{class}
        \unidirectionalAssociation {AuthenticatedData}{part of}{1}{BroadcastMessage}
        \end{tikzpicture}
    }}
    \caption{Class Diagram of Client Side C++ MIRACL Based Back-end}
    \label{fig:class_server_side}
\end{figure}

\subsubsection{Code Structure}
\textcolor{red}{TODO: Add a class diagram for the server-side implementation}

\textcolor{red}{TODO: give a short description on what each function implements}

\subsubsection{Encountered Issues}
\textcolor{red}{TODO: Say something about the difficulties of multithreading MIRACL}
\textcolor{red}{TODO: Say something about the difficulties of implementing the scheme from Kate et al.}
\textcolor{red}{TODO: Say something about the difficulties of serialising messages}
\textcolor{red}{TODO: Say something about the difficulties of inheritance in c++}

\section{Performance Analysis}
\label{sec:performance_analysis}
All performance experiments were conducted on an Intel Core 2.4 GHz i5 processor with 8 Gb of 1600 MHz DDR3L onboard memory. Execution times arise from the aforementioned implementation details applied to Algorithm~\ref{alg:our_scheme}. The results are illustrated in Table~\ref{table:performance_setup}, Table~\ref{table:performance_keygen} and Table~\ref{table:performance_publish_and_retrieve} and further discussed in this section.

\subsection{Setup}
For every PKG $v$, PKG $j$ needs to compute and communicate an additional share $\sigma_{jv}$. Therefore, the execution time of the \texttt{Setup} stage from Algorithm~\ref{alg:our_scheme} is dependent on the total number of PKGs $n$. However, the execution times listed in Table~\ref{table:performance_setup} mainly consist of communication overhead due to the synchronous sockets. Since our current implementation is only simulated in a local environment by sockets listening on different ports, setup times are expected to increase when translated to a more distributed setting.

\begin{table}
  \centering
  \begin{tabular}{@{}rr@{}} \toprule
    Total number of PKGs $n$ & Setup Time (ms) \\ \midrule
    2 & 66.6  \\
    5 & 112.6  \\
    10 & 116.8  \\
    15 & 123.2  \\ 
    50 & 142.3 \\ \bottomrule
  \end{tabular}
  \caption{Performance of the \texttt{Setup} stage in function of the total number of PKGs.}
  \label{table:performance_setup}
\end{table}


\subsection{KeyGen}
The larger the threshold $t$ of the DKG protocol, the more PKGs need to be consulted. For every contacted PKG, two additional pairing computations are required due to the check in step 5 of the \texttt{KeyGen} stage in Algorithm~\ref{alg:our_scheme}. Primarily, these pairing computations together with the communication overhead contribute to the execution times in Table~\ref{table:performance_keygen}. Analogous to the execution times of the \texttt{Setup} stage, the contribution by communication overhead is expected to increase in a distributed DKG environment. 

\begin{table}
  \centering
  \begin{tabular}{@{}rr@{}} \toprule
    Threshold number of PKGs $t$ & Setup Time (ms) \\ \midrule
    2 & 1175.4 \\
    5 & 2785.0 \\
    10 & 5781.2 \\
    15 & 8625.8 \\ 
    50 & 29318.4 \\ \bottomrule
  \end{tabular}
  \caption{Performance of the \texttt{KeyGen} stage in function of the threshold number of PKGs.}
  \label{table:performance_keygen}
\end{table}

\subsection{Publish}
Encryption times are linearly dependent on the number of intended recipients since more intensive pairing computations are required for each additional user included in the intended recipient set, as illustrated by Table~\ref{table:performance_publish_and_retrieve}.

\subsection{Retrieve}
Each recipient has to decrypt $w_i$ an average of $\eta/2$ times to retrieve the secret session key $k$. However, the experiments as shown in Table~\ref{table:performance_publish_and_retrieve} measured the worst-case execution time for the \texttt{Retrieve} stage of Algorithm~\ref{alg:our_scheme} since the recipient had to decrypt all $w_i$ values before retrieving $k$ in the last attempt. Only after recovering $k$, the recipient can decrypt the ciphertext using AES-GCM.

In future optimisations of our current implementation, techniques of randomness reuse should be considered. The concept of randomness reuse as originally proposed by Kurosawa~\cite{art:Kurosawa01} introduces a deterministic component to random elements of a BE scheme such that shorter ciphertexts and computationally more efficient schemes can be achieved. However, randomness reuse should be applied with great care as it can significantly reduce the security level of a scheme. Since randomness reuse depends on the underlying BE scheme, an extensive analysis of the scheme should precede implementation of randomness reuse techniques. Therefore, randomness reuse is currently not included in our implementation.

\begin{table}
  \centering
  \begin{tabular}{@{}rrr@{}} \toprule
    \multicolumn{3}{r}{Execution Time (ms)} \\ \cmidrule(r){2-3}
    Number of Recipients & \texttt{Publish} & \texttt{Retrieve} \\ \midrule
    %%%%%%%%%%%%%%%%%%%%%
    % CCA Secure scheme %
    %%%%%%%%%%%%%%%%%%%%%
    1 & 284.5 & 275.4  \\
    % 5 & 1278.750 \ms & 357.302 \ms \\
    10 & 2564.5  & 460.9  \\
    15 & 3799.6  & 560.6  \\
    % 20 & 5029.470 \ms & 657.030 \ms \\
    % 25 & 6258.510 \ms & 761.765 \ms \\
    50 & 12300.5  & 1237.8  \\
    100 & 25867.7  & 2260.2  \\  \bottomrule
    %%%%%%%%%%%%%%%%%%%%%
    % CPA Secure scheme %
    %%%%%%%%%%%%%%%%%%%%%
    % 1 & 270.872 & 249.1 \\
    % 5 & 1270.1 & 258.7 \\
    % 10 & 2498.6 & 259.6 \\
    % 15 & 3847.3 & 266.1 \\
    % 20 & 4975.4 & 266.9 \\
    % 25 & 6135.0 & 265.0 \\
    % 50 & 12701.3 & 284.214 \\
    % 100 & 25540.5 & 377.8 \\
  \end{tabular}
  \caption{Performance of the \texttt{Publish} and \texttt{Retrieve} stages in function of the number of intended recipients.}
  \label{table:performance_publish_and_retrieve}
\end{table}

\section{Current Limitations}
\label{sec:limitations_of_implementation}
The algorithm as it is currently implemented only serves as a proof-of-concept since it lacks a number of requirements needed for secure use in practice. These aspects were not implemented due to the limited time available. Although all core requirements for the protocol in Algorithm~\ref{alg:our_scheme} are present, only the aspects for practical usage in more hostile environments are missing. However, including these aspects should be straightforward and is only a matter of implementation instead of deliberate design decisions.

\subsection{Client Side}
Since the IBE scheme is integrated in the existing Scramble UI, no drastic adaptations should be made to the client side implementation. The major drawback of our IBE proposal is that it makes the Scramble plugin more dependent on the underlying OSN. Consequently, every OSN should be separately integrated into the Scramble plugin since each OSN offers its own API calls for reading out friend connections. More OSNs than Facebook should be actively supported by the IBE Scramble tool to motivate wide user adapation of the plugin.

\subsection{Server Side}
In its present form, the PKG is only simulated in a local environment. Therefore, it suffices to rely on synchronous communication over C++ sockets each listening on a different port. However, before adaption to a world-wide DKG network is possible, the protocol should take more asynchronous aspects into account such as connection-loss, DOS-attacks or undelivered packets. Kate et al.~\cite{art:KateHG12} propose a more advanced DKG protocol in the asynchronous setting that could be adapted for our IBE setting.

Since the DKG protocol is currently always simulated in a local environment, all PKG sockets communicate their XML messages in plain text. More secure socket protocols should be considered such as SSL~\cite{rfc6101} for adoption to a more hostile distributed setting.

Furthermore, the current assumptions on the PKGs (Section~\ref{sec:updated_model}) are too severe for practical environments. In practice, the current Pedersen DKG scheme~\cite{art:Pedersen91a} is insecure and is better replaced by the one from Gennaro et al.~\cite{art:GennaroJKR07}. If all mentioned updates on the current server side scheme are effectively achieved, more relaxed assumptions on the PKG are in place. With less stringent PKG assumptions, the DKG network could even be partially supported by the OSN providers to show their good intensions of making their networks more private.

\subsection{Limitations Effecting Both Client and Server}
Currently, private key extraction takes the form of a POST request over HTTPS~\cite{rfc2818}. Although the PKGs publish the response in plain text to their PHP website, the communication is encrypted by a self-signed SSL certificate. Ideally, this certificate is signed by a world-wide trusted CA such that the client-side implementation can effectively verify whether it is communicating with a valid PKG.

Although web communication between the client side Scramble tool and the server side PKG is already encrypted, a client can request the private key parameters for every $\id{}$ since there is no authentication mechanism checking the user's identity. However, Facebook provides third party authentication in its API. If a Facebook login dialogue is integrated in the Scramble UI, the returned Facebook authentication token serves as a proof to the PKG that the requester of the private key resembles the owner of the corresponding Facebook profile.
\section{Summary}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
